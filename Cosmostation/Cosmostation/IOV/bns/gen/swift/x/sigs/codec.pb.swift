// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: x/sigs/codec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// UserData just stores the data and is used for serialization.
/// Key is the Address (PubKey.Permission().Address())
///
/// Note: This should not be created from outside the module,
/// User is the entry point you want
struct Sigs_UserData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var pubkey: Crypto_PublicKey {
    get {return _storage._pubkey ?? Crypto_PublicKey()}
    set {_uniqueStorage()._pubkey = newValue}
  }
  /// Returns true if `pubkey` has been explicitly set.
  var hasPubkey: Bool {return _storage._pubkey != nil}
  /// Clears the value of `pubkey`. Subsequent reads from it will return its default value.
  mutating func clearPubkey() {_uniqueStorage()._pubkey = nil}

  var sequence: Int64 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// StdSignature represents the signature, the identity of the signer
/// (the Pubkey), and a sequence number to prevent replay attacks.
///
/// A given signer must submit transactions with the sequence number
/// increasing by 1 each time (starting at 0)
struct Sigs_StdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sequence: Int64 {
    get {return _storage._sequence}
    set {_uniqueStorage()._sequence = newValue}
  }

  var pubkey: Crypto_PublicKey {
    get {return _storage._pubkey ?? Crypto_PublicKey()}
    set {_uniqueStorage()._pubkey = newValue}
  }
  /// Returns true if `pubkey` has been explicitly set.
  var hasPubkey: Bool {return _storage._pubkey != nil}
  /// Clears the value of `pubkey`. Subsequent reads from it will return its default value.
  mutating func clearPubkey() {_uniqueStorage()._pubkey = nil}

  /// Removed Address, Pubkey is more powerful
  var signature: Crypto_Signature {
    get {return _storage._signature ?? Crypto_Signature()}
    set {_uniqueStorage()._signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return _storage._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {_uniqueStorage()._signature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BumpSequenceMsg increments a sequence counter by given amount for a user.
struct Sigs_BumpSequenceMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Increment represents the value by which a sequence value will be
  /// increased. Minumum value is one and maxium value must not be greater than
  /// 1000.
  /// Each transaction increments the sequence by one. This value represents the
  /// total increment value, including the default increment.
  var increment: UInt32 {
    get {return _storage._increment}
    set {_uniqueStorage()._increment = newValue}
  }

  /// User is the address of a user that sequence is to be incremented for.
  var user: Data {
    get {return _storage._user}
    set {_uniqueStorage()._user = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sigs"

extension Sigs_UserData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "pubkey"),
    3: .same(proto: "sequence"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _pubkey: Crypto_PublicKey? = nil
    var _sequence: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _pubkey = source._pubkey
      _sequence = source._sequence
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._pubkey)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._sequence)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._pubkey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._sequence != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sequence, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sigs_UserData, rhs: Sigs_UserData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._pubkey != rhs_storage._pubkey {return false}
        if _storage._sequence != rhs_storage._sequence {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sigs_StdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StdSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sequence"),
    3: .same(proto: "pubkey"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _sequence: Int64 = 0
    var _pubkey: Crypto_PublicKey? = nil
    var _signature: Crypto_Signature? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sequence = source._sequence
      _pubkey = source._pubkey
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._sequence)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._pubkey)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sequence != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sequence, fieldNumber: 2)
      }
      if let v = _storage._pubkey {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._signature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sigs_StdSignature, rhs: Sigs_StdSignature) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sequence != rhs_storage._sequence {return false}
        if _storage._pubkey != rhs_storage._pubkey {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sigs_BumpSequenceMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpSequenceMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "increment"),
    3: .same(proto: "user"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _increment: UInt32 = 0
    var _user: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _increment = source._increment
      _user = source._user
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._increment)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._user)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._increment != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._increment, fieldNumber: 2)
      }
      if !_storage._user.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._user, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sigs_BumpSequenceMsg, rhs: Sigs_BumpSequenceMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._increment != rhs_storage._increment {return false}
        if _storage._user != rhs_storage._user {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
