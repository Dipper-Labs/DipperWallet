// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cmd/bnsd/app/codec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tx contains the message.
///
/// When extending Tx, follow the rules:
/// - range 1-50 is reserved for middlewares,
/// - range 51-inf is reserved for different message types,
/// - keep the same numbers for the same message types in both bnsd and other
///   applications. For example, FeeInfo field is used by both and indexed at
///   first position. Skip unused fields (leave index unused or comment out for
///   clarity).
/// When there is a gap in message sequence numbers - that most likely means some
/// old fields got deprecated. This is done to maintain binary compatibility.
struct Bnsd_Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fees: Cash_FeeInfo {
    get {return _storage._fees ?? Cash_FeeInfo()}
    set {_uniqueStorage()._fees = newValue}
  }
  /// Returns true if `fees` has been explicitly set.
  var hasFees: Bool {return _storage._fees != nil}
  /// Clears the value of `fees`. Subsequent reads from it will return its default value.
  mutating func clearFees() {_uniqueStorage()._fees = nil}

  var signatures: [Sigs_StdSignature] {
    get {return _storage._signatures}
    set {_uniqueStorage()._signatures = newValue}
  }

  /// Multisig contains IDs of multisig contracts.
  /// empty array results in multisig being ignored, basically the same behaviour
  /// as if it never got supplied.
  var multisig: [Data] {
    get {return _storage._multisig}
    set {_uniqueStorage()._multisig = newValue}
  }

  /// msg is a sum type over all allowed messages on this chain.
  var sum: OneOf_Sum? {
    get {return _storage._sum}
    set {_uniqueStorage()._sum = newValue}
  }

  var cashSendMsg: Cash_SendMsg {
    get {
      if case .cashSendMsg(let v)? = _storage._sum {return v}
      return Cash_SendMsg()
    }
    set {_uniqueStorage()._sum = .cashSendMsg(newValue)}
  }

  var escrowCreateMsg: Escrow_CreateMsg {
    get {
      if case .escrowCreateMsg(let v)? = _storage._sum {return v}
      return Escrow_CreateMsg()
    }
    set {_uniqueStorage()._sum = .escrowCreateMsg(newValue)}
  }

  var escrowReleaseMsg: Escrow_ReleaseMsg {
    get {
      if case .escrowReleaseMsg(let v)? = _storage._sum {return v}
      return Escrow_ReleaseMsg()
    }
    set {_uniqueStorage()._sum = .escrowReleaseMsg(newValue)}
  }

  var escrowReturnMsg: Escrow_ReturnMsg {
    get {
      if case .escrowReturnMsg(let v)? = _storage._sum {return v}
      return Escrow_ReturnMsg()
    }
    set {_uniqueStorage()._sum = .escrowReturnMsg(newValue)}
  }

  var escrowUpdatePartiesMsg: Escrow_UpdatePartiesMsg {
    get {
      if case .escrowUpdatePartiesMsg(let v)? = _storage._sum {return v}
      return Escrow_UpdatePartiesMsg()
    }
    set {_uniqueStorage()._sum = .escrowUpdatePartiesMsg(newValue)}
  }

  var multisigCreateMsg: Multisig_CreateMsg {
    get {
      if case .multisigCreateMsg(let v)? = _storage._sum {return v}
      return Multisig_CreateMsg()
    }
    set {_uniqueStorage()._sum = .multisigCreateMsg(newValue)}
  }

  var multisigUpdateMsg: Multisig_UpdateMsg {
    get {
      if case .multisigUpdateMsg(let v)? = _storage._sum {return v}
      return Multisig_UpdateMsg()
    }
    set {_uniqueStorage()._sum = .multisigUpdateMsg(newValue)}
  }

  var validatorsApplyDiffMsg: Validators_ApplyDiffMsg {
    get {
      if case .validatorsApplyDiffMsg(let v)? = _storage._sum {return v}
      return Validators_ApplyDiffMsg()
    }
    set {_uniqueStorage()._sum = .validatorsApplyDiffMsg(newValue)}
  }

  var currencyCreateMsg: Currency_CreateMsg {
    get {
      if case .currencyCreateMsg(let v)? = _storage._sum {return v}
      return Currency_CreateMsg()
    }
    set {_uniqueStorage()._sum = .currencyCreateMsg(newValue)}
  }

  var executeBatchMsg: Bnsd_ExecuteBatchMsg {
    get {
      if case .executeBatchMsg(let v)? = _storage._sum {return v}
      return Bnsd_ExecuteBatchMsg()
    }
    set {_uniqueStorage()._sum = .executeBatchMsg(newValue)}
  }

  var usernameRegisterTokenMsg: Username_RegisterTokenMsg {
    get {
      if case .usernameRegisterTokenMsg(let v)? = _storage._sum {return v}
      return Username_RegisterTokenMsg()
    }
    set {_uniqueStorage()._sum = .usernameRegisterTokenMsg(newValue)}
  }

  var usernameTransferTokenMsg: Username_TransferTokenMsg {
    get {
      if case .usernameTransferTokenMsg(let v)? = _storage._sum {return v}
      return Username_TransferTokenMsg()
    }
    set {_uniqueStorage()._sum = .usernameTransferTokenMsg(newValue)}
  }

  var usernameChangeTokenTargetsMsg: Username_ChangeTokenTargetsMsg {
    get {
      if case .usernameChangeTokenTargetsMsg(let v)? = _storage._sum {return v}
      return Username_ChangeTokenTargetsMsg()
    }
    set {_uniqueStorage()._sum = .usernameChangeTokenTargetsMsg(newValue)}
  }

  var usernameUpdateConfigurationMsg: Username_UpdateConfigurationMsg {
    get {
      if case .usernameUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Username_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .usernameUpdateConfigurationMsg(newValue)}
  }

  var distributionCreateMsg: Distribution_CreateMsg {
    get {
      if case .distributionCreateMsg(let v)? = _storage._sum {return v}
      return Distribution_CreateMsg()
    }
    set {_uniqueStorage()._sum = .distributionCreateMsg(newValue)}
  }

  var distributionMsg: Distribution_DistributeMsg {
    get {
      if case .distributionMsg(let v)? = _storage._sum {return v}
      return Distribution_DistributeMsg()
    }
    set {_uniqueStorage()._sum = .distributionMsg(newValue)}
  }

  var distributionResetMsg: Distribution_ResetMsg {
    get {
      if case .distributionResetMsg(let v)? = _storage._sum {return v}
      return Distribution_ResetMsg()
    }
    set {_uniqueStorage()._sum = .distributionResetMsg(newValue)}
  }

  var migrationUpgradeSchemaMsg: Migration_UpgradeSchemaMsg {
    get {
      if case .migrationUpgradeSchemaMsg(let v)? = _storage._sum {return v}
      return Migration_UpgradeSchemaMsg()
    }
    set {_uniqueStorage()._sum = .migrationUpgradeSchemaMsg(newValue)}
  }

  var aswapCreateMsg: Aswap_CreateMsg {
    get {
      if case .aswapCreateMsg(let v)? = _storage._sum {return v}
      return Aswap_CreateMsg()
    }
    set {_uniqueStorage()._sum = .aswapCreateMsg(newValue)}
  }

  var aswapReleaseMsg: Aswap_ReleaseMsg {
    get {
      if case .aswapReleaseMsg(let v)? = _storage._sum {return v}
      return Aswap_ReleaseMsg()
    }
    set {_uniqueStorage()._sum = .aswapReleaseMsg(newValue)}
  }

  var aswapReturnMsg: Aswap_ReturnMsg {
    get {
      if case .aswapReturnMsg(let v)? = _storage._sum {return v}
      return Aswap_ReturnMsg()
    }
    set {_uniqueStorage()._sum = .aswapReturnMsg(newValue)}
  }

  var govCreateProposalMsg: Gov_CreateProposalMsg {
    get {
      if case .govCreateProposalMsg(let v)? = _storage._sum {return v}
      return Gov_CreateProposalMsg()
    }
    set {_uniqueStorage()._sum = .govCreateProposalMsg(newValue)}
  }

  var govDeleteProposalMsg: Gov_DeleteProposalMsg {
    get {
      if case .govDeleteProposalMsg(let v)? = _storage._sum {return v}
      return Gov_DeleteProposalMsg()
    }
    set {_uniqueStorage()._sum = .govDeleteProposalMsg(newValue)}
  }

  var govVoteMsg: Gov_VoteMsg {
    get {
      if case .govVoteMsg(let v)? = _storage._sum {return v}
      return Gov_VoteMsg()
    }
    set {_uniqueStorage()._sum = .govVoteMsg(newValue)}
  }

  /// Tally is executed via cron only.
  /// gov.TallyMsg gov_tally_msg = 76;
  var govUpdateElectorateMsg: Gov_UpdateElectorateMsg {
    get {
      if case .govUpdateElectorateMsg(let v)? = _storage._sum {return v}
      return Gov_UpdateElectorateMsg()
    }
    set {_uniqueStorage()._sum = .govUpdateElectorateMsg(newValue)}
  }

  var govUpdateElectionRuleMsg: Gov_UpdateElectionRuleMsg {
    get {
      if case .govUpdateElectionRuleMsg(let v)? = _storage._sum {return v}
      return Gov_UpdateElectionRuleMsg()
    }
    set {_uniqueStorage()._sum = .govUpdateElectionRuleMsg(newValue)}
  }

  /// 79 is reserved (see ProposalOptions: TextResolutionMsg)
  var msgfeeSetMsgFeeMsg: Msgfee_SetMsgFeeMsg {
    get {
      if case .msgfeeSetMsgFeeMsg(let v)? = _storage._sum {return v}
      return Msgfee_SetMsgFeeMsg()
    }
    set {_uniqueStorage()._sum = .msgfeeSetMsgFeeMsg(newValue)}
  }

  var datamigrationExecuteMigrationMsg: Datamigration_ExecuteMigrationMsg {
    get {
      if case .datamigrationExecuteMigrationMsg(let v)? = _storage._sum {return v}
      return Datamigration_ExecuteMigrationMsg()
    }
    set {_uniqueStorage()._sum = .datamigrationExecuteMigrationMsg(newValue)}
  }

  var accountUpdateConfigurationMsg: Account_UpdateConfigurationMsg {
    get {
      if case .accountUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Account_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .accountUpdateConfigurationMsg(newValue)}
  }

  var accountRegisterDomainMsg: Account_RegisterDomainMsg {
    get {
      if case .accountRegisterDomainMsg(let v)? = _storage._sum {return v}
      return Account_RegisterDomainMsg()
    }
    set {_uniqueStorage()._sum = .accountRegisterDomainMsg(newValue)}
  }

  var accountReplaceAccountMsgFeesMsg: Account_ReplaceAccountMsgFeesMsg {
    get {
      if case .accountReplaceAccountMsgFeesMsg(let v)? = _storage._sum {return v}
      return Account_ReplaceAccountMsgFeesMsg()
    }
    set {_uniqueStorage()._sum = .accountReplaceAccountMsgFeesMsg(newValue)}
  }

  var accountTransferDomainMsg: Account_TransferDomainMsg {
    get {
      if case .accountTransferDomainMsg(let v)? = _storage._sum {return v}
      return Account_TransferDomainMsg()
    }
    set {_uniqueStorage()._sum = .accountTransferDomainMsg(newValue)}
  }

  var accountRenewDomainMsg: Account_RenewDomainMsg {
    get {
      if case .accountRenewDomainMsg(let v)? = _storage._sum {return v}
      return Account_RenewDomainMsg()
    }
    set {_uniqueStorage()._sum = .accountRenewDomainMsg(newValue)}
  }

  var accountDeleteDomainMsg: Account_DeleteDomainMsg {
    get {
      if case .accountDeleteDomainMsg(let v)? = _storage._sum {return v}
      return Account_DeleteDomainMsg()
    }
    set {_uniqueStorage()._sum = .accountDeleteDomainMsg(newValue)}
  }

  var accountRegisterAccountMsg: Account_RegisterAccountMsg {
    get {
      if case .accountRegisterAccountMsg(let v)? = _storage._sum {return v}
      return Account_RegisterAccountMsg()
    }
    set {_uniqueStorage()._sum = .accountRegisterAccountMsg(newValue)}
  }

  var accountTransferAccountMsg: Account_TransferAccountMsg {
    get {
      if case .accountTransferAccountMsg(let v)? = _storage._sum {return v}
      return Account_TransferAccountMsg()
    }
    set {_uniqueStorage()._sum = .accountTransferAccountMsg(newValue)}
  }

  var accountReplaceAccountTargetsMsg: Account_ReplaceAccountTargetsMsg {
    get {
      if case .accountReplaceAccountTargetsMsg(let v)? = _storage._sum {return v}
      return Account_ReplaceAccountTargetsMsg()
    }
    set {_uniqueStorage()._sum = .accountReplaceAccountTargetsMsg(newValue)}
  }

  var accountDeleteAccountMsg: Account_DeleteAccountMsg {
    get {
      if case .accountDeleteAccountMsg(let v)? = _storage._sum {return v}
      return Account_DeleteAccountMsg()
    }
    set {_uniqueStorage()._sum = .accountDeleteAccountMsg(newValue)}
  }

  var accountFlushDomainMsg: Account_FlushDomainMsg {
    get {
      if case .accountFlushDomainMsg(let v)? = _storage._sum {return v}
      return Account_FlushDomainMsg()
    }
    set {_uniqueStorage()._sum = .accountFlushDomainMsg(newValue)}
  }

  var accountRenewAccountMsg: Account_RenewAccountMsg {
    get {
      if case .accountRenewAccountMsg(let v)? = _storage._sum {return v}
      return Account_RenewAccountMsg()
    }
    set {_uniqueStorage()._sum = .accountRenewAccountMsg(newValue)}
  }

  var accountAddAccountCertificateMsg: Account_AddAccountCertificateMsg {
    get {
      if case .accountAddAccountCertificateMsg(let v)? = _storage._sum {return v}
      return Account_AddAccountCertificateMsg()
    }
    set {_uniqueStorage()._sum = .accountAddAccountCertificateMsg(newValue)}
  }

  var accountDeleteAccountCertificateMsg: Account_DeleteAccountCertificateMsg {
    get {
      if case .accountDeleteAccountCertificateMsg(let v)? = _storage._sum {return v}
      return Account_DeleteAccountCertificateMsg()
    }
    set {_uniqueStorage()._sum = .accountDeleteAccountCertificateMsg(newValue)}
  }

  var preregistrationRegisterMsg: Preregistration_RegisterMsg {
    get {
      if case .preregistrationRegisterMsg(let v)? = _storage._sum {return v}
      return Preregistration_RegisterMsg()
    }
    set {_uniqueStorage()._sum = .preregistrationRegisterMsg(newValue)}
  }

  var cashUpdateConfigurationMsg: Cash_UpdateConfigurationMsg {
    get {
      if case .cashUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Cash_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .cashUpdateConfigurationMsg(newValue)}
  }

  var txfeeUpdateConfigurationMsg: Txfee_UpdateConfigurationMsg {
    get {
      if case .txfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Txfee_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .txfeeUpdateConfigurationMsg(newValue)}
  }

  var termdepositCreateDepositContractMsg: Termdeposit_CreateDepositContractMsg {
    get {
      if case .termdepositCreateDepositContractMsg(let v)? = _storage._sum {return v}
      return Termdeposit_CreateDepositContractMsg()
    }
    set {_uniqueStorage()._sum = .termdepositCreateDepositContractMsg(newValue)}
  }

  var termdepositDepositMsg: Termdeposit_DepositMsg {
    get {
      if case .termdepositDepositMsg(let v)? = _storage._sum {return v}
      return Termdeposit_DepositMsg()
    }
    set {_uniqueStorage()._sum = .termdepositDepositMsg(newValue)}
  }

  var termdepositReleaseDepositMsg: Termdeposit_ReleaseDepositMsg {
    get {
      if case .termdepositReleaseDepositMsg(let v)? = _storage._sum {return v}
      return Termdeposit_ReleaseDepositMsg()
    }
    set {_uniqueStorage()._sum = .termdepositReleaseDepositMsg(newValue)}
  }

  var termdepositUpdateConfigurationMsg: Termdeposit_UpdateConfigurationMsg {
    get {
      if case .termdepositUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Termdeposit_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .termdepositUpdateConfigurationMsg(newValue)}
  }

  var qualityscoreUpdateConfigurationMsg: Qualityscore_UpdateConfigurationMsg {
    get {
      if case .qualityscoreUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Qualityscore_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .qualityscoreUpdateConfigurationMsg(newValue)}
  }

  var preregistrationUpdateConfigurationMsg: Preregistration_UpdateConfigurationMsg {
    get {
      if case .preregistrationUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Preregistration_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .preregistrationUpdateConfigurationMsg(newValue)}
  }

  var msgfeeUpdateConfigurationMsg: Msgfee_UpdateConfigurationMsg {
    get {
      if case .msgfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
      return Msgfee_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._sum = .msgfeeUpdateConfigurationMsg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// msg is a sum type over all allowed messages on this chain.
  enum OneOf_Sum: Equatable {
    case cashSendMsg(Cash_SendMsg)
    case escrowCreateMsg(Escrow_CreateMsg)
    case escrowReleaseMsg(Escrow_ReleaseMsg)
    case escrowReturnMsg(Escrow_ReturnMsg)
    case escrowUpdatePartiesMsg(Escrow_UpdatePartiesMsg)
    case multisigCreateMsg(Multisig_CreateMsg)
    case multisigUpdateMsg(Multisig_UpdateMsg)
    case validatorsApplyDiffMsg(Validators_ApplyDiffMsg)
    case currencyCreateMsg(Currency_CreateMsg)
    case executeBatchMsg(Bnsd_ExecuteBatchMsg)
    case usernameRegisterTokenMsg(Username_RegisterTokenMsg)
    case usernameTransferTokenMsg(Username_TransferTokenMsg)
    case usernameChangeTokenTargetsMsg(Username_ChangeTokenTargetsMsg)
    case usernameUpdateConfigurationMsg(Username_UpdateConfigurationMsg)
    case distributionCreateMsg(Distribution_CreateMsg)
    case distributionMsg(Distribution_DistributeMsg)
    case distributionResetMsg(Distribution_ResetMsg)
    case migrationUpgradeSchemaMsg(Migration_UpgradeSchemaMsg)
    case aswapCreateMsg(Aswap_CreateMsg)
    case aswapReleaseMsg(Aswap_ReleaseMsg)
    case aswapReturnMsg(Aswap_ReturnMsg)
    case govCreateProposalMsg(Gov_CreateProposalMsg)
    case govDeleteProposalMsg(Gov_DeleteProposalMsg)
    case govVoteMsg(Gov_VoteMsg)
    /// Tally is executed via cron only.
    /// gov.TallyMsg gov_tally_msg = 76;
    case govUpdateElectorateMsg(Gov_UpdateElectorateMsg)
    case govUpdateElectionRuleMsg(Gov_UpdateElectionRuleMsg)
    /// 79 is reserved (see ProposalOptions: TextResolutionMsg)
    case msgfeeSetMsgFeeMsg(Msgfee_SetMsgFeeMsg)
    case datamigrationExecuteMigrationMsg(Datamigration_ExecuteMigrationMsg)
    case accountUpdateConfigurationMsg(Account_UpdateConfigurationMsg)
    case accountRegisterDomainMsg(Account_RegisterDomainMsg)
    case accountReplaceAccountMsgFeesMsg(Account_ReplaceAccountMsgFeesMsg)
    case accountTransferDomainMsg(Account_TransferDomainMsg)
    case accountRenewDomainMsg(Account_RenewDomainMsg)
    case accountDeleteDomainMsg(Account_DeleteDomainMsg)
    case accountRegisterAccountMsg(Account_RegisterAccountMsg)
    case accountTransferAccountMsg(Account_TransferAccountMsg)
    case accountReplaceAccountTargetsMsg(Account_ReplaceAccountTargetsMsg)
    case accountDeleteAccountMsg(Account_DeleteAccountMsg)
    case accountFlushDomainMsg(Account_FlushDomainMsg)
    case accountRenewAccountMsg(Account_RenewAccountMsg)
    case accountAddAccountCertificateMsg(Account_AddAccountCertificateMsg)
    case accountDeleteAccountCertificateMsg(Account_DeleteAccountCertificateMsg)
    case preregistrationRegisterMsg(Preregistration_RegisterMsg)
    case cashUpdateConfigurationMsg(Cash_UpdateConfigurationMsg)
    case txfeeUpdateConfigurationMsg(Txfee_UpdateConfigurationMsg)
    case termdepositCreateDepositContractMsg(Termdeposit_CreateDepositContractMsg)
    case termdepositDepositMsg(Termdeposit_DepositMsg)
    case termdepositReleaseDepositMsg(Termdeposit_ReleaseDepositMsg)
    case termdepositUpdateConfigurationMsg(Termdeposit_UpdateConfigurationMsg)
    case qualityscoreUpdateConfigurationMsg(Qualityscore_UpdateConfigurationMsg)
    case preregistrationUpdateConfigurationMsg(Preregistration_UpdateConfigurationMsg)
    case msgfeeUpdateConfigurationMsg(Msgfee_UpdateConfigurationMsg)

  #if !swift(>=4.1)
    static func ==(lhs: Bnsd_Tx.OneOf_Sum, rhs: Bnsd_Tx.OneOf_Sum) -> Bool {
      switch (lhs, rhs) {
      case (.cashSendMsg(let l), .cashSendMsg(let r)): return l == r
      case (.escrowCreateMsg(let l), .escrowCreateMsg(let r)): return l == r
      case (.escrowReleaseMsg(let l), .escrowReleaseMsg(let r)): return l == r
      case (.escrowReturnMsg(let l), .escrowReturnMsg(let r)): return l == r
      case (.escrowUpdatePartiesMsg(let l), .escrowUpdatePartiesMsg(let r)): return l == r
      case (.multisigCreateMsg(let l), .multisigCreateMsg(let r)): return l == r
      case (.multisigUpdateMsg(let l), .multisigUpdateMsg(let r)): return l == r
      case (.validatorsApplyDiffMsg(let l), .validatorsApplyDiffMsg(let r)): return l == r
      case (.currencyCreateMsg(let l), .currencyCreateMsg(let r)): return l == r
      case (.executeBatchMsg(let l), .executeBatchMsg(let r)): return l == r
      case (.usernameRegisterTokenMsg(let l), .usernameRegisterTokenMsg(let r)): return l == r
      case (.usernameTransferTokenMsg(let l), .usernameTransferTokenMsg(let r)): return l == r
      case (.usernameChangeTokenTargetsMsg(let l), .usernameChangeTokenTargetsMsg(let r)): return l == r
      case (.usernameUpdateConfigurationMsg(let l), .usernameUpdateConfigurationMsg(let r)): return l == r
      case (.distributionCreateMsg(let l), .distributionCreateMsg(let r)): return l == r
      case (.distributionMsg(let l), .distributionMsg(let r)): return l == r
      case (.distributionResetMsg(let l), .distributionResetMsg(let r)): return l == r
      case (.migrationUpgradeSchemaMsg(let l), .migrationUpgradeSchemaMsg(let r)): return l == r
      case (.aswapCreateMsg(let l), .aswapCreateMsg(let r)): return l == r
      case (.aswapReleaseMsg(let l), .aswapReleaseMsg(let r)): return l == r
      case (.aswapReturnMsg(let l), .aswapReturnMsg(let r)): return l == r
      case (.govCreateProposalMsg(let l), .govCreateProposalMsg(let r)): return l == r
      case (.govDeleteProposalMsg(let l), .govDeleteProposalMsg(let r)): return l == r
      case (.govVoteMsg(let l), .govVoteMsg(let r)): return l == r
      case (.govUpdateElectorateMsg(let l), .govUpdateElectorateMsg(let r)): return l == r
      case (.govUpdateElectionRuleMsg(let l), .govUpdateElectionRuleMsg(let r)): return l == r
      case (.msgfeeSetMsgFeeMsg(let l), .msgfeeSetMsgFeeMsg(let r)): return l == r
      case (.datamigrationExecuteMigrationMsg(let l), .datamigrationExecuteMigrationMsg(let r)): return l == r
      case (.accountUpdateConfigurationMsg(let l), .accountUpdateConfigurationMsg(let r)): return l == r
      case (.accountRegisterDomainMsg(let l), .accountRegisterDomainMsg(let r)): return l == r
      case (.accountReplaceAccountMsgFeesMsg(let l), .accountReplaceAccountMsgFeesMsg(let r)): return l == r
      case (.accountTransferDomainMsg(let l), .accountTransferDomainMsg(let r)): return l == r
      case (.accountRenewDomainMsg(let l), .accountRenewDomainMsg(let r)): return l == r
      case (.accountDeleteDomainMsg(let l), .accountDeleteDomainMsg(let r)): return l == r
      case (.accountRegisterAccountMsg(let l), .accountRegisterAccountMsg(let r)): return l == r
      case (.accountTransferAccountMsg(let l), .accountTransferAccountMsg(let r)): return l == r
      case (.accountReplaceAccountTargetsMsg(let l), .accountReplaceAccountTargetsMsg(let r)): return l == r
      case (.accountDeleteAccountMsg(let l), .accountDeleteAccountMsg(let r)): return l == r
      case (.accountFlushDomainMsg(let l), .accountFlushDomainMsg(let r)): return l == r
      case (.accountRenewAccountMsg(let l), .accountRenewAccountMsg(let r)): return l == r
      case (.accountAddAccountCertificateMsg(let l), .accountAddAccountCertificateMsg(let r)): return l == r
      case (.accountDeleteAccountCertificateMsg(let l), .accountDeleteAccountCertificateMsg(let r)): return l == r
      case (.preregistrationRegisterMsg(let l), .preregistrationRegisterMsg(let r)): return l == r
      case (.cashUpdateConfigurationMsg(let l), .cashUpdateConfigurationMsg(let r)): return l == r
      case (.txfeeUpdateConfigurationMsg(let l), .txfeeUpdateConfigurationMsg(let r)): return l == r
      case (.termdepositCreateDepositContractMsg(let l), .termdepositCreateDepositContractMsg(let r)): return l == r
      case (.termdepositDepositMsg(let l), .termdepositDepositMsg(let r)): return l == r
      case (.termdepositReleaseDepositMsg(let l), .termdepositReleaseDepositMsg(let r)): return l == r
      case (.termdepositUpdateConfigurationMsg(let l), .termdepositUpdateConfigurationMsg(let r)): return l == r
      case (.qualityscoreUpdateConfigurationMsg(let l), .qualityscoreUpdateConfigurationMsg(let r)): return l == r
      case (.preregistrationUpdateConfigurationMsg(let l), .preregistrationUpdateConfigurationMsg(let r)): return l == r
      case (.msgfeeUpdateConfigurationMsg(let l), .msgfeeUpdateConfigurationMsg(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ExecuteBatchMsg encapsulates multiple messages to support batch transaction
struct Bnsd_ExecuteBatchMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Bnsd_ExecuteBatchMsg.Union] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Union {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sum: OneOf_Sum? {
      get {return _storage._sum}
      set {_uniqueStorage()._sum = newValue}
    }

    var cashSendMsg: Cash_SendMsg {
      get {
        if case .cashSendMsg(let v)? = _storage._sum {return v}
        return Cash_SendMsg()
      }
      set {_uniqueStorage()._sum = .cashSendMsg(newValue)}
    }

    var escrowCreateMsg: Escrow_CreateMsg {
      get {
        if case .escrowCreateMsg(let v)? = _storage._sum {return v}
        return Escrow_CreateMsg()
      }
      set {_uniqueStorage()._sum = .escrowCreateMsg(newValue)}
    }

    var escrowReleaseMsg: Escrow_ReleaseMsg {
      get {
        if case .escrowReleaseMsg(let v)? = _storage._sum {return v}
        return Escrow_ReleaseMsg()
      }
      set {_uniqueStorage()._sum = .escrowReleaseMsg(newValue)}
    }

    var escrowReturnMsg: Escrow_ReturnMsg {
      get {
        if case .escrowReturnMsg(let v)? = _storage._sum {return v}
        return Escrow_ReturnMsg()
      }
      set {_uniqueStorage()._sum = .escrowReturnMsg(newValue)}
    }

    var escrowUpdatePartiesMsg: Escrow_UpdatePartiesMsg {
      get {
        if case .escrowUpdatePartiesMsg(let v)? = _storage._sum {return v}
        return Escrow_UpdatePartiesMsg()
      }
      set {_uniqueStorage()._sum = .escrowUpdatePartiesMsg(newValue)}
    }

    var multisigCreateMsg: Multisig_CreateMsg {
      get {
        if case .multisigCreateMsg(let v)? = _storage._sum {return v}
        return Multisig_CreateMsg()
      }
      set {_uniqueStorage()._sum = .multisigCreateMsg(newValue)}
    }

    var multisigUpdateMsg: Multisig_UpdateMsg {
      get {
        if case .multisigUpdateMsg(let v)? = _storage._sum {return v}
        return Multisig_UpdateMsg()
      }
      set {_uniqueStorage()._sum = .multisigUpdateMsg(newValue)}
    }

    var validatorsApplyDiffMsg: Validators_ApplyDiffMsg {
      get {
        if case .validatorsApplyDiffMsg(let v)? = _storage._sum {return v}
        return Validators_ApplyDiffMsg()
      }
      set {_uniqueStorage()._sum = .validatorsApplyDiffMsg(newValue)}
    }

    var currencyCreateMsg: Currency_CreateMsg {
      get {
        if case .currencyCreateMsg(let v)? = _storage._sum {return v}
        return Currency_CreateMsg()
      }
      set {_uniqueStorage()._sum = .currencyCreateMsg(newValue)}
    }

    /// No recursive batches!
    var usernameRegisterTokenMsg: Username_RegisterTokenMsg {
      get {
        if case .usernameRegisterTokenMsg(let v)? = _storage._sum {return v}
        return Username_RegisterTokenMsg()
      }
      set {_uniqueStorage()._sum = .usernameRegisterTokenMsg(newValue)}
    }

    var usernameTransferTokenMsg: Username_TransferTokenMsg {
      get {
        if case .usernameTransferTokenMsg(let v)? = _storage._sum {return v}
        return Username_TransferTokenMsg()
      }
      set {_uniqueStorage()._sum = .usernameTransferTokenMsg(newValue)}
    }

    var usernameChangeTokenTargetsMsg: Username_ChangeTokenTargetsMsg {
      get {
        if case .usernameChangeTokenTargetsMsg(let v)? = _storage._sum {return v}
        return Username_ChangeTokenTargetsMsg()
      }
      set {_uniqueStorage()._sum = .usernameChangeTokenTargetsMsg(newValue)}
    }

    var usernameUpdateConfigurationMsg: Username_UpdateConfigurationMsg {
      get {
        if case .usernameUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Username_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .usernameUpdateConfigurationMsg(newValue)}
    }

    var distributionCreateMsg: Distribution_CreateMsg {
      get {
        if case .distributionCreateMsg(let v)? = _storage._sum {return v}
        return Distribution_CreateMsg()
      }
      set {_uniqueStorage()._sum = .distributionCreateMsg(newValue)}
    }

    var distributionMsg: Distribution_DistributeMsg {
      get {
        if case .distributionMsg(let v)? = _storage._sum {return v}
        return Distribution_DistributeMsg()
      }
      set {_uniqueStorage()._sum = .distributionMsg(newValue)}
    }

    var distributionResetMsg: Distribution_ResetMsg {
      get {
        if case .distributionResetMsg(let v)? = _storage._sum {return v}
        return Distribution_ResetMsg()
      }
      set {_uniqueStorage()._sum = .distributionResetMsg(newValue)}
    }

    /// upgrade schema is important enough, it should be a solo action
    /// aswap and gov don't make much sense as part of a batch (no vote buying)
    var msgfeeSetMsgFeeMsg: Msgfee_SetMsgFeeMsg {
      get {
        if case .msgfeeSetMsgFeeMsg(let v)? = _storage._sum {return v}
        return Msgfee_SetMsgFeeMsg()
      }
      set {_uniqueStorage()._sum = .msgfeeSetMsgFeeMsg(newValue)}
    }

    var datamigrationExecuteMigrationMsg: Datamigration_ExecuteMigrationMsg {
      get {
        if case .datamigrationExecuteMigrationMsg(let v)? = _storage._sum {return v}
        return Datamigration_ExecuteMigrationMsg()
      }
      set {_uniqueStorage()._sum = .datamigrationExecuteMigrationMsg(newValue)}
    }

    var accountUpdateConfigurationMsg: Account_UpdateConfigurationMsg {
      get {
        if case .accountUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Account_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .accountUpdateConfigurationMsg(newValue)}
    }

    var accountRegisterDomainMsg: Account_RegisterDomainMsg {
      get {
        if case .accountRegisterDomainMsg(let v)? = _storage._sum {return v}
        return Account_RegisterDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountRegisterDomainMsg(newValue)}
    }

    var accountReplaceAccountMsgFeesMsg: Account_ReplaceAccountMsgFeesMsg {
      get {
        if case .accountReplaceAccountMsgFeesMsg(let v)? = _storage._sum {return v}
        return Account_ReplaceAccountMsgFeesMsg()
      }
      set {_uniqueStorage()._sum = .accountReplaceAccountMsgFeesMsg(newValue)}
    }

    var accountTransferDomainMsg: Account_TransferDomainMsg {
      get {
        if case .accountTransferDomainMsg(let v)? = _storage._sum {return v}
        return Account_TransferDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountTransferDomainMsg(newValue)}
    }

    var accountRenewDomainMsg: Account_RenewDomainMsg {
      get {
        if case .accountRenewDomainMsg(let v)? = _storage._sum {return v}
        return Account_RenewDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountRenewDomainMsg(newValue)}
    }

    var accountDeleteDomainMsg: Account_DeleteDomainMsg {
      get {
        if case .accountDeleteDomainMsg(let v)? = _storage._sum {return v}
        return Account_DeleteDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteDomainMsg(newValue)}
    }

    var accountRegisterAccountMsg: Account_RegisterAccountMsg {
      get {
        if case .accountRegisterAccountMsg(let v)? = _storage._sum {return v}
        return Account_RegisterAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountRegisterAccountMsg(newValue)}
    }

    var accountTransferAccountMsg: Account_TransferAccountMsg {
      get {
        if case .accountTransferAccountMsg(let v)? = _storage._sum {return v}
        return Account_TransferAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountTransferAccountMsg(newValue)}
    }

    var accountReplaceAccountTargetsMsg: Account_ReplaceAccountTargetsMsg {
      get {
        if case .accountReplaceAccountTargetsMsg(let v)? = _storage._sum {return v}
        return Account_ReplaceAccountTargetsMsg()
      }
      set {_uniqueStorage()._sum = .accountReplaceAccountTargetsMsg(newValue)}
    }

    var accountDeleteAccountMsg: Account_DeleteAccountMsg {
      get {
        if case .accountDeleteAccountMsg(let v)? = _storage._sum {return v}
        return Account_DeleteAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteAccountMsg(newValue)}
    }

    var accountFlushDomainMsg: Account_FlushDomainMsg {
      get {
        if case .accountFlushDomainMsg(let v)? = _storage._sum {return v}
        return Account_FlushDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountFlushDomainMsg(newValue)}
    }

    var accountRenewAccountMsg: Account_RenewAccountMsg {
      get {
        if case .accountRenewAccountMsg(let v)? = _storage._sum {return v}
        return Account_RenewAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountRenewAccountMsg(newValue)}
    }

    var accountAddAccountCertificateMsg: Account_AddAccountCertificateMsg {
      get {
        if case .accountAddAccountCertificateMsg(let v)? = _storage._sum {return v}
        return Account_AddAccountCertificateMsg()
      }
      set {_uniqueStorage()._sum = .accountAddAccountCertificateMsg(newValue)}
    }

    var accountDeleteAccountCertificateMsg: Account_DeleteAccountCertificateMsg {
      get {
        if case .accountDeleteAccountCertificateMsg(let v)? = _storage._sum {return v}
        return Account_DeleteAccountCertificateMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteAccountCertificateMsg(newValue)}
    }

    /// 96 is used by preregistration
    var cashUpdateConfigurationMsg: Cash_UpdateConfigurationMsg {
      get {
        if case .cashUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Cash_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .cashUpdateConfigurationMsg(newValue)}
    }

    var txfeeUpdateConfigurationMsg: Txfee_UpdateConfigurationMsg {
      get {
        if case .txfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Txfee_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .txfeeUpdateConfigurationMsg(newValue)}
    }

    var termdepositCreateDepositContractMsg: Termdeposit_CreateDepositContractMsg {
      get {
        if case .termdepositCreateDepositContractMsg(let v)? = _storage._sum {return v}
        return Termdeposit_CreateDepositContractMsg()
      }
      set {_uniqueStorage()._sum = .termdepositCreateDepositContractMsg(newValue)}
    }

    var termdepositDepositMsg: Termdeposit_DepositMsg {
      get {
        if case .termdepositDepositMsg(let v)? = _storage._sum {return v}
        return Termdeposit_DepositMsg()
      }
      set {_uniqueStorage()._sum = .termdepositDepositMsg(newValue)}
    }

    var termdepositReleaseDepositMsg: Termdeposit_ReleaseDepositMsg {
      get {
        if case .termdepositReleaseDepositMsg(let v)? = _storage._sum {return v}
        return Termdeposit_ReleaseDepositMsg()
      }
      set {_uniqueStorage()._sum = .termdepositReleaseDepositMsg(newValue)}
    }

    var termdepositUpdateConfigurationMsg: Termdeposit_UpdateConfigurationMsg {
      get {
        if case .termdepositUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Termdeposit_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .termdepositUpdateConfigurationMsg(newValue)}
    }

    var qualityscoreUpdateConfigurationMsg: Qualityscore_UpdateConfigurationMsg {
      get {
        if case .qualityscoreUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Qualityscore_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .qualityscoreUpdateConfigurationMsg(newValue)}
    }

    var preregistrationUpdateConfigurationMsg: Preregistration_UpdateConfigurationMsg {
      get {
        if case .preregistrationUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Preregistration_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .preregistrationUpdateConfigurationMsg(newValue)}
    }

    var msgfeeUpdateConfigurationMsg: Msgfee_UpdateConfigurationMsg {
      get {
        if case .msgfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Msgfee_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .msgfeeUpdateConfigurationMsg(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Sum: Equatable {
      case cashSendMsg(Cash_SendMsg)
      case escrowCreateMsg(Escrow_CreateMsg)
      case escrowReleaseMsg(Escrow_ReleaseMsg)
      case escrowReturnMsg(Escrow_ReturnMsg)
      case escrowUpdatePartiesMsg(Escrow_UpdatePartiesMsg)
      case multisigCreateMsg(Multisig_CreateMsg)
      case multisigUpdateMsg(Multisig_UpdateMsg)
      case validatorsApplyDiffMsg(Validators_ApplyDiffMsg)
      case currencyCreateMsg(Currency_CreateMsg)
      /// No recursive batches!
      case usernameRegisterTokenMsg(Username_RegisterTokenMsg)
      case usernameTransferTokenMsg(Username_TransferTokenMsg)
      case usernameChangeTokenTargetsMsg(Username_ChangeTokenTargetsMsg)
      case usernameUpdateConfigurationMsg(Username_UpdateConfigurationMsg)
      case distributionCreateMsg(Distribution_CreateMsg)
      case distributionMsg(Distribution_DistributeMsg)
      case distributionResetMsg(Distribution_ResetMsg)
      /// upgrade schema is important enough, it should be a solo action
      /// aswap and gov don't make much sense as part of a batch (no vote buying)
      case msgfeeSetMsgFeeMsg(Msgfee_SetMsgFeeMsg)
      case datamigrationExecuteMigrationMsg(Datamigration_ExecuteMigrationMsg)
      case accountUpdateConfigurationMsg(Account_UpdateConfigurationMsg)
      case accountRegisterDomainMsg(Account_RegisterDomainMsg)
      case accountReplaceAccountMsgFeesMsg(Account_ReplaceAccountMsgFeesMsg)
      case accountTransferDomainMsg(Account_TransferDomainMsg)
      case accountRenewDomainMsg(Account_RenewDomainMsg)
      case accountDeleteDomainMsg(Account_DeleteDomainMsg)
      case accountRegisterAccountMsg(Account_RegisterAccountMsg)
      case accountTransferAccountMsg(Account_TransferAccountMsg)
      case accountReplaceAccountTargetsMsg(Account_ReplaceAccountTargetsMsg)
      case accountDeleteAccountMsg(Account_DeleteAccountMsg)
      case accountFlushDomainMsg(Account_FlushDomainMsg)
      case accountRenewAccountMsg(Account_RenewAccountMsg)
      case accountAddAccountCertificateMsg(Account_AddAccountCertificateMsg)
      case accountDeleteAccountCertificateMsg(Account_DeleteAccountCertificateMsg)
      /// 96 is used by preregistration
      case cashUpdateConfigurationMsg(Cash_UpdateConfigurationMsg)
      case txfeeUpdateConfigurationMsg(Txfee_UpdateConfigurationMsg)
      case termdepositCreateDepositContractMsg(Termdeposit_CreateDepositContractMsg)
      case termdepositDepositMsg(Termdeposit_DepositMsg)
      case termdepositReleaseDepositMsg(Termdeposit_ReleaseDepositMsg)
      case termdepositUpdateConfigurationMsg(Termdeposit_UpdateConfigurationMsg)
      case qualityscoreUpdateConfigurationMsg(Qualityscore_UpdateConfigurationMsg)
      case preregistrationUpdateConfigurationMsg(Preregistration_UpdateConfigurationMsg)
      case msgfeeUpdateConfigurationMsg(Msgfee_UpdateConfigurationMsg)

    #if !swift(>=4.1)
      static func ==(lhs: Bnsd_ExecuteBatchMsg.Union.OneOf_Sum, rhs: Bnsd_ExecuteBatchMsg.Union.OneOf_Sum) -> Bool {
        switch (lhs, rhs) {
        case (.cashSendMsg(let l), .cashSendMsg(let r)): return l == r
        case (.escrowCreateMsg(let l), .escrowCreateMsg(let r)): return l == r
        case (.escrowReleaseMsg(let l), .escrowReleaseMsg(let r)): return l == r
        case (.escrowReturnMsg(let l), .escrowReturnMsg(let r)): return l == r
        case (.escrowUpdatePartiesMsg(let l), .escrowUpdatePartiesMsg(let r)): return l == r
        case (.multisigCreateMsg(let l), .multisigCreateMsg(let r)): return l == r
        case (.multisigUpdateMsg(let l), .multisigUpdateMsg(let r)): return l == r
        case (.validatorsApplyDiffMsg(let l), .validatorsApplyDiffMsg(let r)): return l == r
        case (.currencyCreateMsg(let l), .currencyCreateMsg(let r)): return l == r
        case (.usernameRegisterTokenMsg(let l), .usernameRegisterTokenMsg(let r)): return l == r
        case (.usernameTransferTokenMsg(let l), .usernameTransferTokenMsg(let r)): return l == r
        case (.usernameChangeTokenTargetsMsg(let l), .usernameChangeTokenTargetsMsg(let r)): return l == r
        case (.usernameUpdateConfigurationMsg(let l), .usernameUpdateConfigurationMsg(let r)): return l == r
        case (.distributionCreateMsg(let l), .distributionCreateMsg(let r)): return l == r
        case (.distributionMsg(let l), .distributionMsg(let r)): return l == r
        case (.distributionResetMsg(let l), .distributionResetMsg(let r)): return l == r
        case (.msgfeeSetMsgFeeMsg(let l), .msgfeeSetMsgFeeMsg(let r)): return l == r
        case (.datamigrationExecuteMigrationMsg(let l), .datamigrationExecuteMigrationMsg(let r)): return l == r
        case (.accountUpdateConfigurationMsg(let l), .accountUpdateConfigurationMsg(let r)): return l == r
        case (.accountRegisterDomainMsg(let l), .accountRegisterDomainMsg(let r)): return l == r
        case (.accountReplaceAccountMsgFeesMsg(let l), .accountReplaceAccountMsgFeesMsg(let r)): return l == r
        case (.accountTransferDomainMsg(let l), .accountTransferDomainMsg(let r)): return l == r
        case (.accountRenewDomainMsg(let l), .accountRenewDomainMsg(let r)): return l == r
        case (.accountDeleteDomainMsg(let l), .accountDeleteDomainMsg(let r)): return l == r
        case (.accountRegisterAccountMsg(let l), .accountRegisterAccountMsg(let r)): return l == r
        case (.accountTransferAccountMsg(let l), .accountTransferAccountMsg(let r)): return l == r
        case (.accountReplaceAccountTargetsMsg(let l), .accountReplaceAccountTargetsMsg(let r)): return l == r
        case (.accountDeleteAccountMsg(let l), .accountDeleteAccountMsg(let r)): return l == r
        case (.accountFlushDomainMsg(let l), .accountFlushDomainMsg(let r)): return l == r
        case (.accountRenewAccountMsg(let l), .accountRenewAccountMsg(let r)): return l == r
        case (.accountAddAccountCertificateMsg(let l), .accountAddAccountCertificateMsg(let r)): return l == r
        case (.accountDeleteAccountCertificateMsg(let l), .accountDeleteAccountCertificateMsg(let r)): return l == r
        case (.cashUpdateConfigurationMsg(let l), .cashUpdateConfigurationMsg(let r)): return l == r
        case (.txfeeUpdateConfigurationMsg(let l), .txfeeUpdateConfigurationMsg(let r)): return l == r
        case (.termdepositCreateDepositContractMsg(let l), .termdepositCreateDepositContractMsg(let r)): return l == r
        case (.termdepositDepositMsg(let l), .termdepositDepositMsg(let r)): return l == r
        case (.termdepositReleaseDepositMsg(let l), .termdepositReleaseDepositMsg(let r)): return l == r
        case (.termdepositUpdateConfigurationMsg(let l), .termdepositUpdateConfigurationMsg(let r)): return l == r
        case (.qualityscoreUpdateConfigurationMsg(let l), .qualityscoreUpdateConfigurationMsg(let r)): return l == r
        case (.preregistrationUpdateConfigurationMsg(let l), .preregistrationUpdateConfigurationMsg(let r)): return l == r
        case (.msgfeeUpdateConfigurationMsg(let l), .msgfeeUpdateConfigurationMsg(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// ProposalOptions are possible items that can be enacted by a governance vote
/// Trimmed down somewhat arbitrary to what is believed to be reasonable
struct Bnsd_ProposalOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var option: OneOf_Option? {
    get {return _storage._option}
    set {_uniqueStorage()._option = newValue}
  }

  var cashSendMsg: Cash_SendMsg {
    get {
      if case .cashSendMsg(let v)? = _storage._option {return v}
      return Cash_SendMsg()
    }
    set {_uniqueStorage()._option = .cashSendMsg(newValue)}
  }

  var escrowReleaseMsg: Escrow_ReleaseMsg {
    get {
      if case .escrowReleaseMsg(let v)? = _storage._option {return v}
      return Escrow_ReleaseMsg()
    }
    set {_uniqueStorage()._option = .escrowReleaseMsg(newValue)}
  }

  var updateEscrowPartiesMsg: Escrow_UpdatePartiesMsg {
    get {
      if case .updateEscrowPartiesMsg(let v)? = _storage._option {return v}
      return Escrow_UpdatePartiesMsg()
    }
    set {_uniqueStorage()._option = .updateEscrowPartiesMsg(newValue)}
  }

  var multisigUpdateMsg: Multisig_UpdateMsg {
    get {
      if case .multisigUpdateMsg(let v)? = _storage._option {return v}
      return Multisig_UpdateMsg()
    }
    set {_uniqueStorage()._option = .multisigUpdateMsg(newValue)}
  }

  var validatorsApplyDiffMsg: Validators_ApplyDiffMsg {
    get {
      if case .validatorsApplyDiffMsg(let v)? = _storage._option {return v}
      return Validators_ApplyDiffMsg()
    }
    set {_uniqueStorage()._option = .validatorsApplyDiffMsg(newValue)}
  }

  var currencyCreateMsg: Currency_CreateMsg {
    get {
      if case .currencyCreateMsg(let v)? = _storage._option {return v}
      return Currency_CreateMsg()
    }
    set {_uniqueStorage()._option = .currencyCreateMsg(newValue)}
  }

  var executeProposalBatchMsg: Bnsd_ExecuteProposalBatchMsg {
    get {
      if case .executeProposalBatchMsg(let v)? = _storage._option {return v}
      return Bnsd_ExecuteProposalBatchMsg()
    }
    set {_uniqueStorage()._option = .executeProposalBatchMsg(newValue)}
  }

  var usernameRegisterTokenMsg: Username_RegisterTokenMsg {
    get {
      if case .usernameRegisterTokenMsg(let v)? = _storage._option {return v}
      return Username_RegisterTokenMsg()
    }
    set {_uniqueStorage()._option = .usernameRegisterTokenMsg(newValue)}
  }

  var usernameTransferTokenMsg: Username_TransferTokenMsg {
    get {
      if case .usernameTransferTokenMsg(let v)? = _storage._option {return v}
      return Username_TransferTokenMsg()
    }
    set {_uniqueStorage()._option = .usernameTransferTokenMsg(newValue)}
  }

  var usernameChangeTokenTargetsMsg: Username_ChangeTokenTargetsMsg {
    get {
      if case .usernameChangeTokenTargetsMsg(let v)? = _storage._option {return v}
      return Username_ChangeTokenTargetsMsg()
    }
    set {_uniqueStorage()._option = .usernameChangeTokenTargetsMsg(newValue)}
  }

  var usernameUpdateConfigurationMsg: Username_UpdateConfigurationMsg {
    get {
      if case .usernameUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Username_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .usernameUpdateConfigurationMsg(newValue)}
  }

  var distributionCreateMsg: Distribution_CreateMsg {
    get {
      if case .distributionCreateMsg(let v)? = _storage._option {return v}
      return Distribution_CreateMsg()
    }
    set {_uniqueStorage()._option = .distributionCreateMsg(newValue)}
  }

  var distributionMsg: Distribution_DistributeMsg {
    get {
      if case .distributionMsg(let v)? = _storage._option {return v}
      return Distribution_DistributeMsg()
    }
    set {_uniqueStorage()._option = .distributionMsg(newValue)}
  }

  var distributionResetMsg: Distribution_ResetMsg {
    get {
      if case .distributionResetMsg(let v)? = _storage._option {return v}
      return Distribution_ResetMsg()
    }
    set {_uniqueStorage()._option = .distributionResetMsg(newValue)}
  }

  var migrationUpgradeSchemaMsg: Migration_UpgradeSchemaMsg {
    get {
      if case .migrationUpgradeSchemaMsg(let v)? = _storage._option {return v}
      return Migration_UpgradeSchemaMsg()
    }
    set {_uniqueStorage()._option = .migrationUpgradeSchemaMsg(newValue)}
  }

  var govUpdateElectorateMsg: Gov_UpdateElectorateMsg {
    get {
      if case .govUpdateElectorateMsg(let v)? = _storage._option {return v}
      return Gov_UpdateElectorateMsg()
    }
    set {_uniqueStorage()._option = .govUpdateElectorateMsg(newValue)}
  }

  var govUpdateElectionRuleMsg: Gov_UpdateElectionRuleMsg {
    get {
      if case .govUpdateElectionRuleMsg(let v)? = _storage._option {return v}
      return Gov_UpdateElectionRuleMsg()
    }
    set {_uniqueStorage()._option = .govUpdateElectionRuleMsg(newValue)}
  }

  var govCreateTextResolutionMsg: Gov_CreateTextResolutionMsg {
    get {
      if case .govCreateTextResolutionMsg(let v)? = _storage._option {return v}
      return Gov_CreateTextResolutionMsg()
    }
    set {_uniqueStorage()._option = .govCreateTextResolutionMsg(newValue)}
  }

  var msgfeeSetMsgFeeMsg: Msgfee_SetMsgFeeMsg {
    get {
      if case .msgfeeSetMsgFeeMsg(let v)? = _storage._option {return v}
      return Msgfee_SetMsgFeeMsg()
    }
    set {_uniqueStorage()._option = .msgfeeSetMsgFeeMsg(newValue)}
  }

  var datamigrationExecuteMigrationMsg: Datamigration_ExecuteMigrationMsg {
    get {
      if case .datamigrationExecuteMigrationMsg(let v)? = _storage._option {return v}
      return Datamigration_ExecuteMigrationMsg()
    }
    set {_uniqueStorage()._option = .datamigrationExecuteMigrationMsg(newValue)}
  }

  var accountUpdateConfigurationMsg: Account_UpdateConfigurationMsg {
    get {
      if case .accountUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Account_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .accountUpdateConfigurationMsg(newValue)}
  }

  var accountRegisterDomainMsg: Account_RegisterDomainMsg {
    get {
      if case .accountRegisterDomainMsg(let v)? = _storage._option {return v}
      return Account_RegisterDomainMsg()
    }
    set {_uniqueStorage()._option = .accountRegisterDomainMsg(newValue)}
  }

  var accountReplaceAccountMsgFeesMsg: Account_ReplaceAccountMsgFeesMsg {
    get {
      if case .accountReplaceAccountMsgFeesMsg(let v)? = _storage._option {return v}
      return Account_ReplaceAccountMsgFeesMsg()
    }
    set {_uniqueStorage()._option = .accountReplaceAccountMsgFeesMsg(newValue)}
  }

  var accountTransferDomainMsg: Account_TransferDomainMsg {
    get {
      if case .accountTransferDomainMsg(let v)? = _storage._option {return v}
      return Account_TransferDomainMsg()
    }
    set {_uniqueStorage()._option = .accountTransferDomainMsg(newValue)}
  }

  var accountRenewDomainMsg: Account_RenewDomainMsg {
    get {
      if case .accountRenewDomainMsg(let v)? = _storage._option {return v}
      return Account_RenewDomainMsg()
    }
    set {_uniqueStorage()._option = .accountRenewDomainMsg(newValue)}
  }

  var accountDeleteDomainMsg: Account_DeleteDomainMsg {
    get {
      if case .accountDeleteDomainMsg(let v)? = _storage._option {return v}
      return Account_DeleteDomainMsg()
    }
    set {_uniqueStorage()._option = .accountDeleteDomainMsg(newValue)}
  }

  var accountRegisterAccountMsg: Account_RegisterAccountMsg {
    get {
      if case .accountRegisterAccountMsg(let v)? = _storage._option {return v}
      return Account_RegisterAccountMsg()
    }
    set {_uniqueStorage()._option = .accountRegisterAccountMsg(newValue)}
  }

  var accountTransferAccountMsg: Account_TransferAccountMsg {
    get {
      if case .accountTransferAccountMsg(let v)? = _storage._option {return v}
      return Account_TransferAccountMsg()
    }
    set {_uniqueStorage()._option = .accountTransferAccountMsg(newValue)}
  }

  var accountReplaceAccountTargetsMsg: Account_ReplaceAccountTargetsMsg {
    get {
      if case .accountReplaceAccountTargetsMsg(let v)? = _storage._option {return v}
      return Account_ReplaceAccountTargetsMsg()
    }
    set {_uniqueStorage()._option = .accountReplaceAccountTargetsMsg(newValue)}
  }

  var accountDeleteAccountMsg: Account_DeleteAccountMsg {
    get {
      if case .accountDeleteAccountMsg(let v)? = _storage._option {return v}
      return Account_DeleteAccountMsg()
    }
    set {_uniqueStorage()._option = .accountDeleteAccountMsg(newValue)}
  }

  var accountFlushDomainMsg: Account_FlushDomainMsg {
    get {
      if case .accountFlushDomainMsg(let v)? = _storage._option {return v}
      return Account_FlushDomainMsg()
    }
    set {_uniqueStorage()._option = .accountFlushDomainMsg(newValue)}
  }

  var accountRenewAccountMsg: Account_RenewAccountMsg {
    get {
      if case .accountRenewAccountMsg(let v)? = _storage._option {return v}
      return Account_RenewAccountMsg()
    }
    set {_uniqueStorage()._option = .accountRenewAccountMsg(newValue)}
  }

  var accountAddAccountCertificateMsg: Account_AddAccountCertificateMsg {
    get {
      if case .accountAddAccountCertificateMsg(let v)? = _storage._option {return v}
      return Account_AddAccountCertificateMsg()
    }
    set {_uniqueStorage()._option = .accountAddAccountCertificateMsg(newValue)}
  }

  var accountDeleteAccountCertificateMsg: Account_DeleteAccountCertificateMsg {
    get {
      if case .accountDeleteAccountCertificateMsg(let v)? = _storage._option {return v}
      return Account_DeleteAccountCertificateMsg()
    }
    set {_uniqueStorage()._option = .accountDeleteAccountCertificateMsg(newValue)}
  }

  var cashUpdateConfigurationMsg: Cash_UpdateConfigurationMsg {
    get {
      if case .cashUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Cash_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .cashUpdateConfigurationMsg(newValue)}
  }

  var txfeeUpdateConfigurationMsg: Txfee_UpdateConfigurationMsg {
    get {
      if case .txfeeUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Txfee_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .txfeeUpdateConfigurationMsg(newValue)}
  }

  var termdepositCreateDepositContractMsg: Termdeposit_CreateDepositContractMsg {
    get {
      if case .termdepositCreateDepositContractMsg(let v)? = _storage._option {return v}
      return Termdeposit_CreateDepositContractMsg()
    }
    set {_uniqueStorage()._option = .termdepositCreateDepositContractMsg(newValue)}
  }

  var termdepositDepositMsg: Termdeposit_DepositMsg {
    get {
      if case .termdepositDepositMsg(let v)? = _storage._option {return v}
      return Termdeposit_DepositMsg()
    }
    set {_uniqueStorage()._option = .termdepositDepositMsg(newValue)}
  }

  var termdepositReleaseDepositMsg: Termdeposit_ReleaseDepositMsg {
    get {
      if case .termdepositReleaseDepositMsg(let v)? = _storage._option {return v}
      return Termdeposit_ReleaseDepositMsg()
    }
    set {_uniqueStorage()._option = .termdepositReleaseDepositMsg(newValue)}
  }

  var termdepositUpdateConfigurationMsg: Termdeposit_UpdateConfigurationMsg {
    get {
      if case .termdepositUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Termdeposit_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .termdepositUpdateConfigurationMsg(newValue)}
  }

  var qualityscoreUpdateConfigurationMsg: Qualityscore_UpdateConfigurationMsg {
    get {
      if case .qualityscoreUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Qualityscore_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .qualityscoreUpdateConfigurationMsg(newValue)}
  }

  var preregistrationUpdateConfigurationMsg: Preregistration_UpdateConfigurationMsg {
    get {
      if case .preregistrationUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Preregistration_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .preregistrationUpdateConfigurationMsg(newValue)}
  }

  var msgfeeUpdateConfigurationMsg: Msgfee_UpdateConfigurationMsg {
    get {
      if case .msgfeeUpdateConfigurationMsg(let v)? = _storage._option {return v}
      return Msgfee_UpdateConfigurationMsg()
    }
    set {_uniqueStorage()._option = .msgfeeUpdateConfigurationMsg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Option: Equatable {
    case cashSendMsg(Cash_SendMsg)
    case escrowReleaseMsg(Escrow_ReleaseMsg)
    case updateEscrowPartiesMsg(Escrow_UpdatePartiesMsg)
    case multisigUpdateMsg(Multisig_UpdateMsg)
    case validatorsApplyDiffMsg(Validators_ApplyDiffMsg)
    case currencyCreateMsg(Currency_CreateMsg)
    case executeProposalBatchMsg(Bnsd_ExecuteProposalBatchMsg)
    case usernameRegisterTokenMsg(Username_RegisterTokenMsg)
    case usernameTransferTokenMsg(Username_TransferTokenMsg)
    case usernameChangeTokenTargetsMsg(Username_ChangeTokenTargetsMsg)
    case usernameUpdateConfigurationMsg(Username_UpdateConfigurationMsg)
    case distributionCreateMsg(Distribution_CreateMsg)
    case distributionMsg(Distribution_DistributeMsg)
    case distributionResetMsg(Distribution_ResetMsg)
    case migrationUpgradeSchemaMsg(Migration_UpgradeSchemaMsg)
    case govUpdateElectorateMsg(Gov_UpdateElectorateMsg)
    case govUpdateElectionRuleMsg(Gov_UpdateElectionRuleMsg)
    case govCreateTextResolutionMsg(Gov_CreateTextResolutionMsg)
    case msgfeeSetMsgFeeMsg(Msgfee_SetMsgFeeMsg)
    case datamigrationExecuteMigrationMsg(Datamigration_ExecuteMigrationMsg)
    case accountUpdateConfigurationMsg(Account_UpdateConfigurationMsg)
    case accountRegisterDomainMsg(Account_RegisterDomainMsg)
    case accountReplaceAccountMsgFeesMsg(Account_ReplaceAccountMsgFeesMsg)
    case accountTransferDomainMsg(Account_TransferDomainMsg)
    case accountRenewDomainMsg(Account_RenewDomainMsg)
    case accountDeleteDomainMsg(Account_DeleteDomainMsg)
    case accountRegisterAccountMsg(Account_RegisterAccountMsg)
    case accountTransferAccountMsg(Account_TransferAccountMsg)
    case accountReplaceAccountTargetsMsg(Account_ReplaceAccountTargetsMsg)
    case accountDeleteAccountMsg(Account_DeleteAccountMsg)
    case accountFlushDomainMsg(Account_FlushDomainMsg)
    case accountRenewAccountMsg(Account_RenewAccountMsg)
    case accountAddAccountCertificateMsg(Account_AddAccountCertificateMsg)
    case accountDeleteAccountCertificateMsg(Account_DeleteAccountCertificateMsg)
    case cashUpdateConfigurationMsg(Cash_UpdateConfigurationMsg)
    case txfeeUpdateConfigurationMsg(Txfee_UpdateConfigurationMsg)
    case termdepositCreateDepositContractMsg(Termdeposit_CreateDepositContractMsg)
    case termdepositDepositMsg(Termdeposit_DepositMsg)
    case termdepositReleaseDepositMsg(Termdeposit_ReleaseDepositMsg)
    case termdepositUpdateConfigurationMsg(Termdeposit_UpdateConfigurationMsg)
    case qualityscoreUpdateConfigurationMsg(Qualityscore_UpdateConfigurationMsg)
    case preregistrationUpdateConfigurationMsg(Preregistration_UpdateConfigurationMsg)
    case msgfeeUpdateConfigurationMsg(Msgfee_UpdateConfigurationMsg)

  #if !swift(>=4.1)
    static func ==(lhs: Bnsd_ProposalOptions.OneOf_Option, rhs: Bnsd_ProposalOptions.OneOf_Option) -> Bool {
      switch (lhs, rhs) {
      case (.cashSendMsg(let l), .cashSendMsg(let r)): return l == r
      case (.escrowReleaseMsg(let l), .escrowReleaseMsg(let r)): return l == r
      case (.updateEscrowPartiesMsg(let l), .updateEscrowPartiesMsg(let r)): return l == r
      case (.multisigUpdateMsg(let l), .multisigUpdateMsg(let r)): return l == r
      case (.validatorsApplyDiffMsg(let l), .validatorsApplyDiffMsg(let r)): return l == r
      case (.currencyCreateMsg(let l), .currencyCreateMsg(let r)): return l == r
      case (.executeProposalBatchMsg(let l), .executeProposalBatchMsg(let r)): return l == r
      case (.usernameRegisterTokenMsg(let l), .usernameRegisterTokenMsg(let r)): return l == r
      case (.usernameTransferTokenMsg(let l), .usernameTransferTokenMsg(let r)): return l == r
      case (.usernameChangeTokenTargetsMsg(let l), .usernameChangeTokenTargetsMsg(let r)): return l == r
      case (.usernameUpdateConfigurationMsg(let l), .usernameUpdateConfigurationMsg(let r)): return l == r
      case (.distributionCreateMsg(let l), .distributionCreateMsg(let r)): return l == r
      case (.distributionMsg(let l), .distributionMsg(let r)): return l == r
      case (.distributionResetMsg(let l), .distributionResetMsg(let r)): return l == r
      case (.migrationUpgradeSchemaMsg(let l), .migrationUpgradeSchemaMsg(let r)): return l == r
      case (.govUpdateElectorateMsg(let l), .govUpdateElectorateMsg(let r)): return l == r
      case (.govUpdateElectionRuleMsg(let l), .govUpdateElectionRuleMsg(let r)): return l == r
      case (.govCreateTextResolutionMsg(let l), .govCreateTextResolutionMsg(let r)): return l == r
      case (.msgfeeSetMsgFeeMsg(let l), .msgfeeSetMsgFeeMsg(let r)): return l == r
      case (.datamigrationExecuteMigrationMsg(let l), .datamigrationExecuteMigrationMsg(let r)): return l == r
      case (.accountUpdateConfigurationMsg(let l), .accountUpdateConfigurationMsg(let r)): return l == r
      case (.accountRegisterDomainMsg(let l), .accountRegisterDomainMsg(let r)): return l == r
      case (.accountReplaceAccountMsgFeesMsg(let l), .accountReplaceAccountMsgFeesMsg(let r)): return l == r
      case (.accountTransferDomainMsg(let l), .accountTransferDomainMsg(let r)): return l == r
      case (.accountRenewDomainMsg(let l), .accountRenewDomainMsg(let r)): return l == r
      case (.accountDeleteDomainMsg(let l), .accountDeleteDomainMsg(let r)): return l == r
      case (.accountRegisterAccountMsg(let l), .accountRegisterAccountMsg(let r)): return l == r
      case (.accountTransferAccountMsg(let l), .accountTransferAccountMsg(let r)): return l == r
      case (.accountReplaceAccountTargetsMsg(let l), .accountReplaceAccountTargetsMsg(let r)): return l == r
      case (.accountDeleteAccountMsg(let l), .accountDeleteAccountMsg(let r)): return l == r
      case (.accountFlushDomainMsg(let l), .accountFlushDomainMsg(let r)): return l == r
      case (.accountRenewAccountMsg(let l), .accountRenewAccountMsg(let r)): return l == r
      case (.accountAddAccountCertificateMsg(let l), .accountAddAccountCertificateMsg(let r)): return l == r
      case (.accountDeleteAccountCertificateMsg(let l), .accountDeleteAccountCertificateMsg(let r)): return l == r
      case (.cashUpdateConfigurationMsg(let l), .cashUpdateConfigurationMsg(let r)): return l == r
      case (.txfeeUpdateConfigurationMsg(let l), .txfeeUpdateConfigurationMsg(let r)): return l == r
      case (.termdepositCreateDepositContractMsg(let l), .termdepositCreateDepositContractMsg(let r)): return l == r
      case (.termdepositDepositMsg(let l), .termdepositDepositMsg(let r)): return l == r
      case (.termdepositReleaseDepositMsg(let l), .termdepositReleaseDepositMsg(let r)): return l == r
      case (.termdepositUpdateConfigurationMsg(let l), .termdepositUpdateConfigurationMsg(let r)): return l == r
      case (.qualityscoreUpdateConfigurationMsg(let l), .qualityscoreUpdateConfigurationMsg(let r)): return l == r
      case (.preregistrationUpdateConfigurationMsg(let l), .preregistrationUpdateConfigurationMsg(let r)): return l == r
      case (.msgfeeUpdateConfigurationMsg(let l), .msgfeeUpdateConfigurationMsg(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Bnsd_ExecuteProposalBatchMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var messages: [Bnsd_ExecuteProposalBatchMsg.Union] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Union {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sum: OneOf_Sum? {
      get {return _storage._sum}
      set {_uniqueStorage()._sum = newValue}
    }

    var sendMsg: Cash_SendMsg {
      get {
        if case .sendMsg(let v)? = _storage._sum {return v}
        return Cash_SendMsg()
      }
      set {_uniqueStorage()._sum = .sendMsg(newValue)}
    }

    var escrowReleaseMsg: Escrow_ReleaseMsg {
      get {
        if case .escrowReleaseMsg(let v)? = _storage._sum {return v}
        return Escrow_ReleaseMsg()
      }
      set {_uniqueStorage()._sum = .escrowReleaseMsg(newValue)}
    }

    var updateEscrowPartiesMsg: Escrow_UpdatePartiesMsg {
      get {
        if case .updateEscrowPartiesMsg(let v)? = _storage._sum {return v}
        return Escrow_UpdatePartiesMsg()
      }
      set {_uniqueStorage()._sum = .updateEscrowPartiesMsg(newValue)}
    }

    var multisigUpdateMsg: Multisig_UpdateMsg {
      get {
        if case .multisigUpdateMsg(let v)? = _storage._sum {return v}
        return Multisig_UpdateMsg()
      }
      set {_uniqueStorage()._sum = .multisigUpdateMsg(newValue)}
    }

    var validatorsApplyDiffMsg: Validators_ApplyDiffMsg {
      get {
        if case .validatorsApplyDiffMsg(let v)? = _storage._sum {return v}
        return Validators_ApplyDiffMsg()
      }
      set {_uniqueStorage()._sum = .validatorsApplyDiffMsg(newValue)}
    }

    /// no recursive batches
    var usernameRegisterTokenMsg: Username_RegisterTokenMsg {
      get {
        if case .usernameRegisterTokenMsg(let v)? = _storage._sum {return v}
        return Username_RegisterTokenMsg()
      }
      set {_uniqueStorage()._sum = .usernameRegisterTokenMsg(newValue)}
    }

    var usernameTransferTokenMsg: Username_TransferTokenMsg {
      get {
        if case .usernameTransferTokenMsg(let v)? = _storage._sum {return v}
        return Username_TransferTokenMsg()
      }
      set {_uniqueStorage()._sum = .usernameTransferTokenMsg(newValue)}
    }

    var usernameChangeTokenTargetsMsg: Username_ChangeTokenTargetsMsg {
      get {
        if case .usernameChangeTokenTargetsMsg(let v)? = _storage._sum {return v}
        return Username_ChangeTokenTargetsMsg()
      }
      set {_uniqueStorage()._sum = .usernameChangeTokenTargetsMsg(newValue)}
    }

    var usernameUpdateConfigurationMsg: Username_UpdateConfigurationMsg {
      get {
        if case .usernameUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Username_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .usernameUpdateConfigurationMsg(newValue)}
    }

    var distributionCreateMsg: Distribution_CreateMsg {
      get {
        if case .distributionCreateMsg(let v)? = _storage._sum {return v}
        return Distribution_CreateMsg()
      }
      set {_uniqueStorage()._sum = .distributionCreateMsg(newValue)}
    }

    var distributionMsg: Distribution_DistributeMsg {
      get {
        if case .distributionMsg(let v)? = _storage._sum {return v}
        return Distribution_DistributeMsg()
      }
      set {_uniqueStorage()._sum = .distributionMsg(newValue)}
    }

    var distributionResetMsg: Distribution_ResetMsg {
      get {
        if case .distributionResetMsg(let v)? = _storage._sum {return v}
        return Distribution_ResetMsg()
      }
      set {_uniqueStorage()._sum = .distributionResetMsg(newValue)}
    }

    /// don't allow UpgradeSchema as part of a batch, as effects are too confusing
    var govUpdateElectorateMsg: Gov_UpdateElectorateMsg {
      get {
        if case .govUpdateElectorateMsg(let v)? = _storage._sum {return v}
        return Gov_UpdateElectorateMsg()
      }
      set {_uniqueStorage()._sum = .govUpdateElectorateMsg(newValue)}
    }

    var govUpdateElectionRuleMsg: Gov_UpdateElectionRuleMsg {
      get {
        if case .govUpdateElectionRuleMsg(let v)? = _storage._sum {return v}
        return Gov_UpdateElectionRuleMsg()
      }
      set {_uniqueStorage()._sum = .govUpdateElectionRuleMsg(newValue)}
    }

    var govCreateTextResolutionMsg: Gov_CreateTextResolutionMsg {
      get {
        if case .govCreateTextResolutionMsg(let v)? = _storage._sum {return v}
        return Gov_CreateTextResolutionMsg()
      }
      set {_uniqueStorage()._sum = .govCreateTextResolutionMsg(newValue)}
    }

    var msgfeeSetMsgFeeMsg: Msgfee_SetMsgFeeMsg {
      get {
        if case .msgfeeSetMsgFeeMsg(let v)? = _storage._sum {return v}
        return Msgfee_SetMsgFeeMsg()
      }
      set {_uniqueStorage()._sum = .msgfeeSetMsgFeeMsg(newValue)}
    }

    var datamigrationExecuteMigrationMsg: Datamigration_ExecuteMigrationMsg {
      get {
        if case .datamigrationExecuteMigrationMsg(let v)? = _storage._sum {return v}
        return Datamigration_ExecuteMigrationMsg()
      }
      set {_uniqueStorage()._sum = .datamigrationExecuteMigrationMsg(newValue)}
    }

    var accountUpdateConfigurationMsg: Account_UpdateConfigurationMsg {
      get {
        if case .accountUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Account_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .accountUpdateConfigurationMsg(newValue)}
    }

    var accountRegisterDomainMsg: Account_RegisterDomainMsg {
      get {
        if case .accountRegisterDomainMsg(let v)? = _storage._sum {return v}
        return Account_RegisterDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountRegisterDomainMsg(newValue)}
    }

    var accountReplaceAccountMsgFeesMsg: Account_ReplaceAccountMsgFeesMsg {
      get {
        if case .accountReplaceAccountMsgFeesMsg(let v)? = _storage._sum {return v}
        return Account_ReplaceAccountMsgFeesMsg()
      }
      set {_uniqueStorage()._sum = .accountReplaceAccountMsgFeesMsg(newValue)}
    }

    var accountTransferDomainMsg: Account_TransferDomainMsg {
      get {
        if case .accountTransferDomainMsg(let v)? = _storage._sum {return v}
        return Account_TransferDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountTransferDomainMsg(newValue)}
    }

    var accountRenewDomainMsg: Account_RenewDomainMsg {
      get {
        if case .accountRenewDomainMsg(let v)? = _storage._sum {return v}
        return Account_RenewDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountRenewDomainMsg(newValue)}
    }

    var accountDeleteDomainMsg: Account_DeleteDomainMsg {
      get {
        if case .accountDeleteDomainMsg(let v)? = _storage._sum {return v}
        return Account_DeleteDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteDomainMsg(newValue)}
    }

    var accountRegisterAccountMsg: Account_RegisterAccountMsg {
      get {
        if case .accountRegisterAccountMsg(let v)? = _storage._sum {return v}
        return Account_RegisterAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountRegisterAccountMsg(newValue)}
    }

    var accountTransferAccountMsg: Account_TransferAccountMsg {
      get {
        if case .accountTransferAccountMsg(let v)? = _storage._sum {return v}
        return Account_TransferAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountTransferAccountMsg(newValue)}
    }

    var accountReplaceAccountTargetsMsg: Account_ReplaceAccountTargetsMsg {
      get {
        if case .accountReplaceAccountTargetsMsg(let v)? = _storage._sum {return v}
        return Account_ReplaceAccountTargetsMsg()
      }
      set {_uniqueStorage()._sum = .accountReplaceAccountTargetsMsg(newValue)}
    }

    var accountDeleteAccountMsg: Account_DeleteAccountMsg {
      get {
        if case .accountDeleteAccountMsg(let v)? = _storage._sum {return v}
        return Account_DeleteAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteAccountMsg(newValue)}
    }

    var accountFlushDomainMsg: Account_FlushDomainMsg {
      get {
        if case .accountFlushDomainMsg(let v)? = _storage._sum {return v}
        return Account_FlushDomainMsg()
      }
      set {_uniqueStorage()._sum = .accountFlushDomainMsg(newValue)}
    }

    var accountRenewAccountMsg: Account_RenewAccountMsg {
      get {
        if case .accountRenewAccountMsg(let v)? = _storage._sum {return v}
        return Account_RenewAccountMsg()
      }
      set {_uniqueStorage()._sum = .accountRenewAccountMsg(newValue)}
    }

    var accountAddAccountCertificateMsg: Account_AddAccountCertificateMsg {
      get {
        if case .accountAddAccountCertificateMsg(let v)? = _storage._sum {return v}
        return Account_AddAccountCertificateMsg()
      }
      set {_uniqueStorage()._sum = .accountAddAccountCertificateMsg(newValue)}
    }

    var accountDeleteAccountCertificateMsg: Account_DeleteAccountCertificateMsg {
      get {
        if case .accountDeleteAccountCertificateMsg(let v)? = _storage._sum {return v}
        return Account_DeleteAccountCertificateMsg()
      }
      set {_uniqueStorage()._sum = .accountDeleteAccountCertificateMsg(newValue)}
    }

    var cashUpdateConfigurationMsg: Cash_UpdateConfigurationMsg {
      get {
        if case .cashUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Cash_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .cashUpdateConfigurationMsg(newValue)}
    }

    var txfeeUpdateConfigurationMsg: Txfee_UpdateConfigurationMsg {
      get {
        if case .txfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Txfee_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .txfeeUpdateConfigurationMsg(newValue)}
    }

    var termdepositCreateDepositContractMsg: Termdeposit_CreateDepositContractMsg {
      get {
        if case .termdepositCreateDepositContractMsg(let v)? = _storage._sum {return v}
        return Termdeposit_CreateDepositContractMsg()
      }
      set {_uniqueStorage()._sum = .termdepositCreateDepositContractMsg(newValue)}
    }

    var termdepositDepositMsg: Termdeposit_DepositMsg {
      get {
        if case .termdepositDepositMsg(let v)? = _storage._sum {return v}
        return Termdeposit_DepositMsg()
      }
      set {_uniqueStorage()._sum = .termdepositDepositMsg(newValue)}
    }

    var termdepositReleaseDepositMsg: Termdeposit_ReleaseDepositMsg {
      get {
        if case .termdepositReleaseDepositMsg(let v)? = _storage._sum {return v}
        return Termdeposit_ReleaseDepositMsg()
      }
      set {_uniqueStorage()._sum = .termdepositReleaseDepositMsg(newValue)}
    }

    var termdepositUpdateConfigurationMsg: Termdeposit_UpdateConfigurationMsg {
      get {
        if case .termdepositUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Termdeposit_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .termdepositUpdateConfigurationMsg(newValue)}
    }

    var qualityscoreUpdateConfigurationMsg: Qualityscore_UpdateConfigurationMsg {
      get {
        if case .qualityscoreUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Qualityscore_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .qualityscoreUpdateConfigurationMsg(newValue)}
    }

    var preregistrationUpdateConfigurationMsg: Preregistration_UpdateConfigurationMsg {
      get {
        if case .preregistrationUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Preregistration_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .preregistrationUpdateConfigurationMsg(newValue)}
    }

    var msgfeeUpdateConfigurationMsg: Msgfee_UpdateConfigurationMsg {
      get {
        if case .msgfeeUpdateConfigurationMsg(let v)? = _storage._sum {return v}
        return Msgfee_UpdateConfigurationMsg()
      }
      set {_uniqueStorage()._sum = .msgfeeUpdateConfigurationMsg(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Sum: Equatable {
      case sendMsg(Cash_SendMsg)
      case escrowReleaseMsg(Escrow_ReleaseMsg)
      case updateEscrowPartiesMsg(Escrow_UpdatePartiesMsg)
      case multisigUpdateMsg(Multisig_UpdateMsg)
      case validatorsApplyDiffMsg(Validators_ApplyDiffMsg)
      /// no recursive batches
      case usernameRegisterTokenMsg(Username_RegisterTokenMsg)
      case usernameTransferTokenMsg(Username_TransferTokenMsg)
      case usernameChangeTokenTargetsMsg(Username_ChangeTokenTargetsMsg)
      case usernameUpdateConfigurationMsg(Username_UpdateConfigurationMsg)
      case distributionCreateMsg(Distribution_CreateMsg)
      case distributionMsg(Distribution_DistributeMsg)
      case distributionResetMsg(Distribution_ResetMsg)
      /// don't allow UpgradeSchema as part of a batch, as effects are too confusing
      case govUpdateElectorateMsg(Gov_UpdateElectorateMsg)
      case govUpdateElectionRuleMsg(Gov_UpdateElectionRuleMsg)
      case govCreateTextResolutionMsg(Gov_CreateTextResolutionMsg)
      case msgfeeSetMsgFeeMsg(Msgfee_SetMsgFeeMsg)
      case datamigrationExecuteMigrationMsg(Datamigration_ExecuteMigrationMsg)
      case accountUpdateConfigurationMsg(Account_UpdateConfigurationMsg)
      case accountRegisterDomainMsg(Account_RegisterDomainMsg)
      case accountReplaceAccountMsgFeesMsg(Account_ReplaceAccountMsgFeesMsg)
      case accountTransferDomainMsg(Account_TransferDomainMsg)
      case accountRenewDomainMsg(Account_RenewDomainMsg)
      case accountDeleteDomainMsg(Account_DeleteDomainMsg)
      case accountRegisterAccountMsg(Account_RegisterAccountMsg)
      case accountTransferAccountMsg(Account_TransferAccountMsg)
      case accountReplaceAccountTargetsMsg(Account_ReplaceAccountTargetsMsg)
      case accountDeleteAccountMsg(Account_DeleteAccountMsg)
      case accountFlushDomainMsg(Account_FlushDomainMsg)
      case accountRenewAccountMsg(Account_RenewAccountMsg)
      case accountAddAccountCertificateMsg(Account_AddAccountCertificateMsg)
      case accountDeleteAccountCertificateMsg(Account_DeleteAccountCertificateMsg)
      case cashUpdateConfigurationMsg(Cash_UpdateConfigurationMsg)
      case txfeeUpdateConfigurationMsg(Txfee_UpdateConfigurationMsg)
      case termdepositCreateDepositContractMsg(Termdeposit_CreateDepositContractMsg)
      case termdepositDepositMsg(Termdeposit_DepositMsg)
      case termdepositReleaseDepositMsg(Termdeposit_ReleaseDepositMsg)
      case termdepositUpdateConfigurationMsg(Termdeposit_UpdateConfigurationMsg)
      case qualityscoreUpdateConfigurationMsg(Qualityscore_UpdateConfigurationMsg)
      case preregistrationUpdateConfigurationMsg(Preregistration_UpdateConfigurationMsg)
      case msgfeeUpdateConfigurationMsg(Msgfee_UpdateConfigurationMsg)

    #if !swift(>=4.1)
      static func ==(lhs: Bnsd_ExecuteProposalBatchMsg.Union.OneOf_Sum, rhs: Bnsd_ExecuteProposalBatchMsg.Union.OneOf_Sum) -> Bool {
        switch (lhs, rhs) {
        case (.sendMsg(let l), .sendMsg(let r)): return l == r
        case (.escrowReleaseMsg(let l), .escrowReleaseMsg(let r)): return l == r
        case (.updateEscrowPartiesMsg(let l), .updateEscrowPartiesMsg(let r)): return l == r
        case (.multisigUpdateMsg(let l), .multisigUpdateMsg(let r)): return l == r
        case (.validatorsApplyDiffMsg(let l), .validatorsApplyDiffMsg(let r)): return l == r
        case (.usernameRegisterTokenMsg(let l), .usernameRegisterTokenMsg(let r)): return l == r
        case (.usernameTransferTokenMsg(let l), .usernameTransferTokenMsg(let r)): return l == r
        case (.usernameChangeTokenTargetsMsg(let l), .usernameChangeTokenTargetsMsg(let r)): return l == r
        case (.usernameUpdateConfigurationMsg(let l), .usernameUpdateConfigurationMsg(let r)): return l == r
        case (.distributionCreateMsg(let l), .distributionCreateMsg(let r)): return l == r
        case (.distributionMsg(let l), .distributionMsg(let r)): return l == r
        case (.distributionResetMsg(let l), .distributionResetMsg(let r)): return l == r
        case (.govUpdateElectorateMsg(let l), .govUpdateElectorateMsg(let r)): return l == r
        case (.govUpdateElectionRuleMsg(let l), .govUpdateElectionRuleMsg(let r)): return l == r
        case (.govCreateTextResolutionMsg(let l), .govCreateTextResolutionMsg(let r)): return l == r
        case (.msgfeeSetMsgFeeMsg(let l), .msgfeeSetMsgFeeMsg(let r)): return l == r
        case (.datamigrationExecuteMigrationMsg(let l), .datamigrationExecuteMigrationMsg(let r)): return l == r
        case (.accountUpdateConfigurationMsg(let l), .accountUpdateConfigurationMsg(let r)): return l == r
        case (.accountRegisterDomainMsg(let l), .accountRegisterDomainMsg(let r)): return l == r
        case (.accountReplaceAccountMsgFeesMsg(let l), .accountReplaceAccountMsgFeesMsg(let r)): return l == r
        case (.accountTransferDomainMsg(let l), .accountTransferDomainMsg(let r)): return l == r
        case (.accountRenewDomainMsg(let l), .accountRenewDomainMsg(let r)): return l == r
        case (.accountDeleteDomainMsg(let l), .accountDeleteDomainMsg(let r)): return l == r
        case (.accountRegisterAccountMsg(let l), .accountRegisterAccountMsg(let r)): return l == r
        case (.accountTransferAccountMsg(let l), .accountTransferAccountMsg(let r)): return l == r
        case (.accountReplaceAccountTargetsMsg(let l), .accountReplaceAccountTargetsMsg(let r)): return l == r
        case (.accountDeleteAccountMsg(let l), .accountDeleteAccountMsg(let r)): return l == r
        case (.accountFlushDomainMsg(let l), .accountFlushDomainMsg(let r)): return l == r
        case (.accountRenewAccountMsg(let l), .accountRenewAccountMsg(let r)): return l == r
        case (.accountAddAccountCertificateMsg(let l), .accountAddAccountCertificateMsg(let r)): return l == r
        case (.accountDeleteAccountCertificateMsg(let l), .accountDeleteAccountCertificateMsg(let r)): return l == r
        case (.cashUpdateConfigurationMsg(let l), .cashUpdateConfigurationMsg(let r)): return l == r
        case (.txfeeUpdateConfigurationMsg(let l), .txfeeUpdateConfigurationMsg(let r)): return l == r
        case (.termdepositCreateDepositContractMsg(let l), .termdepositCreateDepositContractMsg(let r)): return l == r
        case (.termdepositDepositMsg(let l), .termdepositDepositMsg(let r)): return l == r
        case (.termdepositReleaseDepositMsg(let l), .termdepositReleaseDepositMsg(let r)): return l == r
        case (.termdepositUpdateConfigurationMsg(let l), .termdepositUpdateConfigurationMsg(let r)): return l == r
        case (.qualityscoreUpdateConfigurationMsg(let l), .qualityscoreUpdateConfigurationMsg(let r)): return l == r
        case (.preregistrationUpdateConfigurationMsg(let l), .preregistrationUpdateConfigurationMsg(let r)): return l == r
        case (.msgfeeUpdateConfigurationMsg(let l), .msgfeeUpdateConfigurationMsg(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

/// CronTask is a format used by the CronMarshaler to marshal and unmarshal cron
/// task.
///
/// When there is a gap in message sequence numbers - that most likely means some
/// old fields got deprecated. This is done to maintain binary compatibility.
struct Bnsd_CronTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authenticators contains a list of conditions that authenticate execution
  /// of this task.
  /// This is one of the main differences between the CronTask and Tx entities.
  /// CronTask is created interanlly and does not have to be signed. Because we
  /// use the same handlers as for the Tx to process a cron task, we must
  /// provide authentication method. This attribute contains all authentication
  /// conditions required for execution, that will be inserted into the context.
  var authenticators: [Data] {
    get {return _storage._authenticators}
    set {_uniqueStorage()._authenticators = newValue}
  }

  /// Use the same indexes for the messages as the Tx message.
  var sum: OneOf_Sum? {
    get {return _storage._sum}
    set {_uniqueStorage()._sum = newValue}
  }

  var escrowReleaseMsg: Escrow_ReleaseMsg {
    get {
      if case .escrowReleaseMsg(let v)? = _storage._sum {return v}
      return Escrow_ReleaseMsg()
    }
    set {_uniqueStorage()._sum = .escrowReleaseMsg(newValue)}
  }

  var escrowReturnMsg: Escrow_ReturnMsg {
    get {
      if case .escrowReturnMsg(let v)? = _storage._sum {return v}
      return Escrow_ReturnMsg()
    }
    set {_uniqueStorage()._sum = .escrowReturnMsg(newValue)}
  }

  var distributionDistributeMsg: Distribution_DistributeMsg {
    get {
      if case .distributionDistributeMsg(let v)? = _storage._sum {return v}
      return Distribution_DistributeMsg()
    }
    set {_uniqueStorage()._sum = .distributionDistributeMsg(newValue)}
  }

  var aswapReleaseMsg: Aswap_ReleaseMsg {
    get {
      if case .aswapReleaseMsg(let v)? = _storage._sum {return v}
      return Aswap_ReleaseMsg()
    }
    set {_uniqueStorage()._sum = .aswapReleaseMsg(newValue)}
  }

  var govTallyMsg: Gov_TallyMsg {
    get {
      if case .govTallyMsg(let v)? = _storage._sum {return v}
      return Gov_TallyMsg()
    }
    set {_uniqueStorage()._sum = .govTallyMsg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Use the same indexes for the messages as the Tx message.
  enum OneOf_Sum: Equatable {
    case escrowReleaseMsg(Escrow_ReleaseMsg)
    case escrowReturnMsg(Escrow_ReturnMsg)
    case distributionDistributeMsg(Distribution_DistributeMsg)
    case aswapReleaseMsg(Aswap_ReleaseMsg)
    case govTallyMsg(Gov_TallyMsg)

  #if !swift(>=4.1)
    static func ==(lhs: Bnsd_CronTask.OneOf_Sum, rhs: Bnsd_CronTask.OneOf_Sum) -> Bool {
      switch (lhs, rhs) {
      case (.escrowReleaseMsg(let l), .escrowReleaseMsg(let r)): return l == r
      case (.escrowReturnMsg(let l), .escrowReturnMsg(let r)): return l == r
      case (.distributionDistributeMsg(let l), .distributionDistributeMsg(let r)): return l == r
      case (.aswapReleaseMsg(let l), .aswapReleaseMsg(let r)): return l == r
      case (.govTallyMsg(let l), .govTallyMsg(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bnsd"

extension Bnsd_Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fees"),
    2: .same(proto: "signatures"),
    4: .same(proto: "multisig"),
    51: .standard(proto: "cash_send_msg"),
    52: .standard(proto: "escrow_create_msg"),
    53: .standard(proto: "escrow_release_msg"),
    54: .standard(proto: "escrow_return_msg"),
    55: .standard(proto: "escrow_update_parties_msg"),
    56: .standard(proto: "multisig_create_msg"),
    57: .standard(proto: "multisig_update_msg"),
    58: .standard(proto: "validators_apply_diff_msg"),
    59: .standard(proto: "currency_create_msg"),
    60: .standard(proto: "execute_batch_msg"),
    61: .standard(proto: "username_register_token_msg"),
    62: .standard(proto: "username_transfer_token_msg"),
    63: .standard(proto: "username_change_token_targets_msg"),
    64: .standard(proto: "username_update_configuration_msg"),
    66: .standard(proto: "distribution_create_msg"),
    67: .standard(proto: "distribution_msg"),
    68: .standard(proto: "distribution_reset_msg"),
    69: .standard(proto: "migration_upgrade_schema_msg"),
    70: .standard(proto: "aswap_create_msg"),
    71: .standard(proto: "aswap_release_msg"),
    72: .standard(proto: "aswap_return_msg"),
    73: .standard(proto: "gov_create_proposal_msg"),
    74: .standard(proto: "gov_delete_proposal_msg"),
    75: .standard(proto: "gov_vote_msg"),
    77: .standard(proto: "gov_update_electorate_msg"),
    78: .standard(proto: "gov_update_election_rule_msg"),
    80: .standard(proto: "msgfee_set_msg_fee_msg"),
    81: .standard(proto: "datamigration_execute_migration_msg"),
    82: .standard(proto: "account_update_configuration_msg"),
    83: .standard(proto: "account_register_domain_msg"),
    84: .standard(proto: "account_replace_account_msg_fees_msg"),
    85: .standard(proto: "account_transfer_domain_msg"),
    86: .standard(proto: "account_renew_domain_msg"),
    87: .standard(proto: "account_delete_domain_msg"),
    88: .standard(proto: "account_register_account_msg"),
    89: .standard(proto: "account_transfer_account_msg"),
    90: .standard(proto: "account_replace_account_targets_msg"),
    91: .standard(proto: "account_delete_account_msg"),
    92: .standard(proto: "account_flush_domain_msg"),
    93: .standard(proto: "account_renew_account_msg"),
    94: .standard(proto: "account_add_account_certificate_msg"),
    95: .standard(proto: "account_delete_account_certificate_msg"),
    96: .standard(proto: "preregistration_register_msg"),
    97: .standard(proto: "cash_update_configuration_msg"),
    98: .standard(proto: "txfee_update_configuration_msg"),
    99: .standard(proto: "termdeposit_create_deposit_contract_msg"),
    100: .standard(proto: "termdeposit_deposit_msg"),
    101: .standard(proto: "termdeposit_release_deposit_msg"),
    102: .standard(proto: "termdeposit_update_configuration_msg"),
    103: .standard(proto: "qualityscore_update_configuration_msg"),
    104: .standard(proto: "preregistration_update_configuration_msg"),
    105: .standard(proto: "msgfee_update_configuration_msg"),
  ]

  fileprivate class _StorageClass {
    var _fees: Cash_FeeInfo? = nil
    var _signatures: [Sigs_StdSignature] = []
    var _multisig: [Data] = []
    var _sum: Bnsd_Tx.OneOf_Sum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _fees = source._fees
      _signatures = source._signatures
      _multisig = source._multisig
      _sum = source._sum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._fees)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._signatures)
        case 4: try decoder.decodeRepeatedBytesField(value: &_storage._multisig)
        case 51:
          var v: Cash_SendMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .cashSendMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .cashSendMsg(v)}
        case 52:
          var v: Escrow_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowCreateMsg(v)}
        case 53:
          var v: Escrow_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReleaseMsg(v)}
        case 54:
          var v: Escrow_ReturnMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReturnMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReturnMsg(v)}
        case 55:
          var v: Escrow_UpdatePartiesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowUpdatePartiesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowUpdatePartiesMsg(v)}
        case 56:
          var v: Multisig_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multisigCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multisigCreateMsg(v)}
        case 57:
          var v: Multisig_UpdateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multisigUpdateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multisigUpdateMsg(v)}
        case 58:
          var v: Validators_ApplyDiffMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .validatorsApplyDiffMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .validatorsApplyDiffMsg(v)}
        case 59:
          var v: Currency_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .currencyCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .currencyCreateMsg(v)}
        case 60:
          var v: Bnsd_ExecuteBatchMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .executeBatchMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .executeBatchMsg(v)}
        case 61:
          var v: Username_RegisterTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameRegisterTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameRegisterTokenMsg(v)}
        case 62:
          var v: Username_TransferTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameTransferTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameTransferTokenMsg(v)}
        case 63:
          var v: Username_ChangeTokenTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameChangeTokenTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameChangeTokenTargetsMsg(v)}
        case 64:
          var v: Username_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameUpdateConfigurationMsg(v)}
        case 66:
          var v: Distribution_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionCreateMsg(v)}
        case 67:
          var v: Distribution_DistributeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionMsg(v)}
        case 68:
          var v: Distribution_ResetMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionResetMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionResetMsg(v)}
        case 69:
          var v: Migration_UpgradeSchemaMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .migrationUpgradeSchemaMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .migrationUpgradeSchemaMsg(v)}
        case 70:
          var v: Aswap_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .aswapCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .aswapCreateMsg(v)}
        case 71:
          var v: Aswap_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .aswapReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .aswapReleaseMsg(v)}
        case 72:
          var v: Aswap_ReturnMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .aswapReturnMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .aswapReturnMsg(v)}
        case 73:
          var v: Gov_CreateProposalMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govCreateProposalMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govCreateProposalMsg(v)}
        case 74:
          var v: Gov_DeleteProposalMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govDeleteProposalMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govDeleteProposalMsg(v)}
        case 75:
          var v: Gov_VoteMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govVoteMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govVoteMsg(v)}
        case 77:
          var v: Gov_UpdateElectorateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectorateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govUpdateElectorateMsg(v)}
        case 78:
          var v: Gov_UpdateElectionRuleMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectionRuleMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govUpdateElectionRuleMsg(v)}
        case 80:
          var v: Msgfee_SetMsgFeeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeSetMsgFeeMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeSetMsgFeeMsg(v)}
        case 81:
          var v: Datamigration_ExecuteMigrationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .datamigrationExecuteMigrationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .datamigrationExecuteMigrationMsg(v)}
        case 82:
          var v: Account_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountUpdateConfigurationMsg(v)}
        case 83:
          var v: Account_RegisterDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterDomainMsg(v)}
        case 84:
          var v: Account_ReplaceAccountMsgFeesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountMsgFeesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountMsgFeesMsg(v)}
        case 85:
          var v: Account_TransferDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferDomainMsg(v)}
        case 86:
          var v: Account_RenewDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewDomainMsg(v)}
        case 87:
          var v: Account_DeleteDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteDomainMsg(v)}
        case 88:
          var v: Account_RegisterAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterAccountMsg(v)}
        case 89:
          var v: Account_TransferAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferAccountMsg(v)}
        case 90:
          var v: Account_ReplaceAccountTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountTargetsMsg(v)}
        case 91:
          var v: Account_DeleteAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountMsg(v)}
        case 92:
          var v: Account_FlushDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountFlushDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountFlushDomainMsg(v)}
        case 93:
          var v: Account_RenewAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewAccountMsg(v)}
        case 94:
          var v: Account_AddAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountAddAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountAddAccountCertificateMsg(v)}
        case 95:
          var v: Account_DeleteAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountCertificateMsg(v)}
        case 96:
          var v: Preregistration_RegisterMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .preregistrationRegisterMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .preregistrationRegisterMsg(v)}
        case 97:
          var v: Cash_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .cashUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .cashUpdateConfigurationMsg(v)}
        case 98:
          var v: Txfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .txfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .txfeeUpdateConfigurationMsg(v)}
        case 99:
          var v: Termdeposit_CreateDepositContractMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositCreateDepositContractMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositCreateDepositContractMsg(v)}
        case 100:
          var v: Termdeposit_DepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositDepositMsg(v)}
        case 101:
          var v: Termdeposit_ReleaseDepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositReleaseDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositReleaseDepositMsg(v)}
        case 102:
          var v: Termdeposit_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositUpdateConfigurationMsg(v)}
        case 103:
          var v: Qualityscore_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .qualityscoreUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .qualityscoreUpdateConfigurationMsg(v)}
        case 104:
          var v: Preregistration_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .preregistrationUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .preregistrationUpdateConfigurationMsg(v)}
        case 105:
          var v: Msgfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeUpdateConfigurationMsg(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._fees {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signatures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._signatures, fieldNumber: 2)
      }
      if !_storage._multisig.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._multisig, fieldNumber: 4)
      }
      switch _storage._sum {
      case .cashSendMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case .escrowCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      case .escrowReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .escrowReturnMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      case .escrowUpdatePartiesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      case .multisigCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      case .multisigUpdateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      case .validatorsApplyDiffMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      case .currencyCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      case .executeBatchMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      case .usernameRegisterTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      case .usernameTransferTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      case .usernameChangeTokenTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      case .usernameUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      case .distributionCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      case .distributionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .distributionResetMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      case .migrationUpgradeSchemaMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      case .aswapCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      case .aswapReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      case .aswapReturnMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      case .govCreateProposalMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      case .govDeleteProposalMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      case .govVoteMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      case .govUpdateElectorateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      case .govUpdateElectionRuleMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      case .msgfeeSetMsgFeeMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      case .datamigrationExecuteMigrationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      case .accountUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      case .accountRegisterDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      case .accountReplaceAccountMsgFeesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      case .accountTransferDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      case .accountRenewDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      case .accountDeleteDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      case .accountRegisterAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      case .accountTransferAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      case .accountReplaceAccountTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      case .accountDeleteAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      case .accountFlushDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
      case .accountRenewAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      case .accountAddAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
      case .accountDeleteAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
      case .preregistrationRegisterMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
      case .cashUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
      case .txfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      case .termdepositCreateDepositContractMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      case .termdepositDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .termdepositReleaseDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .termdepositUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case .qualityscoreUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case .preregistrationUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      case .msgfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_Tx, rhs: Bnsd_Tx) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fees != rhs_storage._fees {return false}
        if _storage._signatures != rhs_storage._signatures {return false}
        if _storage._multisig != rhs_storage._multisig {return false}
        if _storage._sum != rhs_storage._sum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_ExecuteBatchMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteBatchMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_ExecuteBatchMsg, rhs: Bnsd_ExecuteBatchMsg) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_ExecuteBatchMsg.Union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Bnsd_ExecuteBatchMsg.protoMessageName + ".Union"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    51: .standard(proto: "cash_send_msg"),
    52: .standard(proto: "escrow_create_msg"),
    53: .standard(proto: "escrow_release_msg"),
    54: .standard(proto: "escrow_return_msg"),
    55: .standard(proto: "escrow_update_parties_msg"),
    56: .standard(proto: "multisig_create_msg"),
    57: .standard(proto: "multisig_update_msg"),
    58: .standard(proto: "validators_apply_diff_msg"),
    59: .standard(proto: "currency_create_msg"),
    61: .standard(proto: "username_register_token_msg"),
    62: .standard(proto: "username_transfer_token_msg"),
    63: .standard(proto: "username_change_token_targets_msg"),
    64: .standard(proto: "username_update_configuration_msg"),
    66: .standard(proto: "distribution_create_msg"),
    67: .standard(proto: "distribution_msg"),
    68: .standard(proto: "distribution_reset_msg"),
    80: .standard(proto: "msgfee_set_msg_fee_msg"),
    81: .standard(proto: "datamigration_execute_migration_msg"),
    82: .standard(proto: "account_update_configuration_msg"),
    83: .standard(proto: "account_register_domain_msg"),
    84: .standard(proto: "account_replace_account_msg_fees_msg"),
    85: .standard(proto: "account_transfer_domain_msg"),
    86: .standard(proto: "account_renew_domain_msg"),
    87: .standard(proto: "account_delete_domain_msg"),
    88: .standard(proto: "account_register_account_msg"),
    89: .standard(proto: "account_transfer_account_msg"),
    90: .standard(proto: "account_replace_account_targets_msg"),
    91: .standard(proto: "account_delete_account_msg"),
    92: .standard(proto: "account_flush_domain_msg"),
    93: .standard(proto: "account_renew_account_msg"),
    94: .standard(proto: "account_add_account_certificate_msg"),
    95: .standard(proto: "account_delete_account_certificate_msg"),
    97: .standard(proto: "cash_update_configuration_msg"),
    98: .standard(proto: "txfee_update_configuration_msg"),
    99: .standard(proto: "termdeposit_create_deposit_contract_msg"),
    100: .standard(proto: "termdeposit_deposit_msg"),
    101: .standard(proto: "termdeposit_release_deposit_msg"),
    102: .standard(proto: "termdeposit_update_configuration_msg"),
    103: .standard(proto: "qualityscore_update_configuration_msg"),
    104: .standard(proto: "preregistration_update_configuration_msg"),
    105: .standard(proto: "msgfee_update_configuration_msg"),
  ]

  fileprivate class _StorageClass {
    var _sum: Bnsd_ExecuteBatchMsg.Union.OneOf_Sum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sum = source._sum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 51:
          var v: Cash_SendMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .cashSendMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .cashSendMsg(v)}
        case 52:
          var v: Escrow_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowCreateMsg(v)}
        case 53:
          var v: Escrow_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReleaseMsg(v)}
        case 54:
          var v: Escrow_ReturnMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReturnMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReturnMsg(v)}
        case 55:
          var v: Escrow_UpdatePartiesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowUpdatePartiesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowUpdatePartiesMsg(v)}
        case 56:
          var v: Multisig_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multisigCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multisigCreateMsg(v)}
        case 57:
          var v: Multisig_UpdateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multisigUpdateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multisigUpdateMsg(v)}
        case 58:
          var v: Validators_ApplyDiffMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .validatorsApplyDiffMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .validatorsApplyDiffMsg(v)}
        case 59:
          var v: Currency_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .currencyCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .currencyCreateMsg(v)}
        case 61:
          var v: Username_RegisterTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameRegisterTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameRegisterTokenMsg(v)}
        case 62:
          var v: Username_TransferTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameTransferTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameTransferTokenMsg(v)}
        case 63:
          var v: Username_ChangeTokenTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameChangeTokenTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameChangeTokenTargetsMsg(v)}
        case 64:
          var v: Username_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameUpdateConfigurationMsg(v)}
        case 66:
          var v: Distribution_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionCreateMsg(v)}
        case 67:
          var v: Distribution_DistributeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionMsg(v)}
        case 68:
          var v: Distribution_ResetMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionResetMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionResetMsg(v)}
        case 80:
          var v: Msgfee_SetMsgFeeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeSetMsgFeeMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeSetMsgFeeMsg(v)}
        case 81:
          var v: Datamigration_ExecuteMigrationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .datamigrationExecuteMigrationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .datamigrationExecuteMigrationMsg(v)}
        case 82:
          var v: Account_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountUpdateConfigurationMsg(v)}
        case 83:
          var v: Account_RegisterDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterDomainMsg(v)}
        case 84:
          var v: Account_ReplaceAccountMsgFeesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountMsgFeesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountMsgFeesMsg(v)}
        case 85:
          var v: Account_TransferDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferDomainMsg(v)}
        case 86:
          var v: Account_RenewDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewDomainMsg(v)}
        case 87:
          var v: Account_DeleteDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteDomainMsg(v)}
        case 88:
          var v: Account_RegisterAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterAccountMsg(v)}
        case 89:
          var v: Account_TransferAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferAccountMsg(v)}
        case 90:
          var v: Account_ReplaceAccountTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountTargetsMsg(v)}
        case 91:
          var v: Account_DeleteAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountMsg(v)}
        case 92:
          var v: Account_FlushDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountFlushDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountFlushDomainMsg(v)}
        case 93:
          var v: Account_RenewAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewAccountMsg(v)}
        case 94:
          var v: Account_AddAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountAddAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountAddAccountCertificateMsg(v)}
        case 95:
          var v: Account_DeleteAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountCertificateMsg(v)}
        case 97:
          var v: Cash_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .cashUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .cashUpdateConfigurationMsg(v)}
        case 98:
          var v: Txfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .txfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .txfeeUpdateConfigurationMsg(v)}
        case 99:
          var v: Termdeposit_CreateDepositContractMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositCreateDepositContractMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositCreateDepositContractMsg(v)}
        case 100:
          var v: Termdeposit_DepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositDepositMsg(v)}
        case 101:
          var v: Termdeposit_ReleaseDepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositReleaseDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositReleaseDepositMsg(v)}
        case 102:
          var v: Termdeposit_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositUpdateConfigurationMsg(v)}
        case 103:
          var v: Qualityscore_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .qualityscoreUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .qualityscoreUpdateConfigurationMsg(v)}
        case 104:
          var v: Preregistration_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .preregistrationUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .preregistrationUpdateConfigurationMsg(v)}
        case 105:
          var v: Msgfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeUpdateConfigurationMsg(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._sum {
      case .cashSendMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case .escrowCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      case .escrowReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .escrowReturnMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      case .escrowUpdatePartiesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      case .multisigCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      case .multisigUpdateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      case .validatorsApplyDiffMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      case .currencyCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      case .usernameRegisterTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      case .usernameTransferTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      case .usernameChangeTokenTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      case .usernameUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      case .distributionCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      case .distributionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .distributionResetMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      case .msgfeeSetMsgFeeMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      case .datamigrationExecuteMigrationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      case .accountUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      case .accountRegisterDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      case .accountReplaceAccountMsgFeesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      case .accountTransferDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      case .accountRenewDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      case .accountDeleteDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      case .accountRegisterAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      case .accountTransferAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      case .accountReplaceAccountTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      case .accountDeleteAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      case .accountFlushDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
      case .accountRenewAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      case .accountAddAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
      case .accountDeleteAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
      case .cashUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
      case .txfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      case .termdepositCreateDepositContractMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      case .termdepositDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .termdepositReleaseDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .termdepositUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case .qualityscoreUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case .preregistrationUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      case .msgfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_ExecuteBatchMsg.Union, rhs: Bnsd_ExecuteBatchMsg.Union) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sum != rhs_storage._sum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_ProposalOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    51: .standard(proto: "cash_send_msg"),
    53: .standard(proto: "escrow_release_msg"),
    55: .standard(proto: "update_escrow_parties_msg"),
    57: .standard(proto: "multisig_update_msg"),
    58: .standard(proto: "validators_apply_diff_msg"),
    59: .standard(proto: "currency_create_msg"),
    60: .standard(proto: "execute_proposal_batch_msg"),
    61: .standard(proto: "username_register_token_msg"),
    62: .standard(proto: "username_transfer_token_msg"),
    63: .standard(proto: "username_change_token_targets_msg"),
    64: .standard(proto: "username_update_configuration_msg"),
    66: .standard(proto: "distribution_create_msg"),
    67: .standard(proto: "distribution_msg"),
    68: .standard(proto: "distribution_reset_msg"),
    69: .standard(proto: "migration_upgrade_schema_msg"),
    77: .standard(proto: "gov_update_electorate_msg"),
    78: .standard(proto: "gov_update_election_rule_msg"),
    79: .standard(proto: "gov_create_text_resolution_msg"),
    80: .standard(proto: "msgfee_set_msg_fee_msg"),
    81: .standard(proto: "datamigration_execute_migration_msg"),
    82: .standard(proto: "account_update_configuration_msg"),
    83: .standard(proto: "account_register_domain_msg"),
    84: .standard(proto: "account_replace_account_msg_fees_msg"),
    85: .standard(proto: "account_transfer_domain_msg"),
    86: .standard(proto: "account_renew_domain_msg"),
    87: .standard(proto: "account_delete_domain_msg"),
    88: .standard(proto: "account_register_account_msg"),
    89: .standard(proto: "account_transfer_account_msg"),
    90: .standard(proto: "account_replace_account_targets_msg"),
    91: .standard(proto: "account_delete_account_msg"),
    92: .standard(proto: "account_flush_domain_msg"),
    93: .standard(proto: "account_renew_account_msg"),
    94: .standard(proto: "account_add_account_certificate_msg"),
    95: .standard(proto: "account_delete_account_certificate_msg"),
    97: .standard(proto: "cash_update_configuration_msg"),
    98: .standard(proto: "txfee_update_configuration_msg"),
    99: .standard(proto: "termdeposit_create_deposit_contract_msg"),
    100: .standard(proto: "termdeposit_deposit_msg"),
    101: .standard(proto: "termdeposit_release_deposit_msg"),
    102: .standard(proto: "termdeposit_update_configuration_msg"),
    103: .standard(proto: "qualityscore_update_configuration_msg"),
    104: .standard(proto: "preregistration_update_configuration_msg"),
    105: .standard(proto: "msgfee_update_configuration_msg"),
  ]

  fileprivate class _StorageClass {
    var _option: Bnsd_ProposalOptions.OneOf_Option?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _option = source._option
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 51:
          var v: Cash_SendMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .cashSendMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .cashSendMsg(v)}
        case 53:
          var v: Escrow_ReleaseMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .escrowReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .escrowReleaseMsg(v)}
        case 55:
          var v: Escrow_UpdatePartiesMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .updateEscrowPartiesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .updateEscrowPartiesMsg(v)}
        case 57:
          var v: Multisig_UpdateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .multisigUpdateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .multisigUpdateMsg(v)}
        case 58:
          var v: Validators_ApplyDiffMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .validatorsApplyDiffMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .validatorsApplyDiffMsg(v)}
        case 59:
          var v: Currency_CreateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .currencyCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .currencyCreateMsg(v)}
        case 60:
          var v: Bnsd_ExecuteProposalBatchMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .executeProposalBatchMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .executeProposalBatchMsg(v)}
        case 61:
          var v: Username_RegisterTokenMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .usernameRegisterTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .usernameRegisterTokenMsg(v)}
        case 62:
          var v: Username_TransferTokenMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .usernameTransferTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .usernameTransferTokenMsg(v)}
        case 63:
          var v: Username_ChangeTokenTargetsMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .usernameChangeTokenTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .usernameChangeTokenTargetsMsg(v)}
        case 64:
          var v: Username_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .usernameUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .usernameUpdateConfigurationMsg(v)}
        case 66:
          var v: Distribution_CreateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .distributionCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .distributionCreateMsg(v)}
        case 67:
          var v: Distribution_DistributeMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .distributionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .distributionMsg(v)}
        case 68:
          var v: Distribution_ResetMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .distributionResetMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .distributionResetMsg(v)}
        case 69:
          var v: Migration_UpgradeSchemaMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .migrationUpgradeSchemaMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .migrationUpgradeSchemaMsg(v)}
        case 77:
          var v: Gov_UpdateElectorateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectorateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .govUpdateElectorateMsg(v)}
        case 78:
          var v: Gov_UpdateElectionRuleMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectionRuleMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .govUpdateElectionRuleMsg(v)}
        case 79:
          var v: Gov_CreateTextResolutionMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .govCreateTextResolutionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .govCreateTextResolutionMsg(v)}
        case 80:
          var v: Msgfee_SetMsgFeeMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .msgfeeSetMsgFeeMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .msgfeeSetMsgFeeMsg(v)}
        case 81:
          var v: Datamigration_ExecuteMigrationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .datamigrationExecuteMigrationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .datamigrationExecuteMigrationMsg(v)}
        case 82:
          var v: Account_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountUpdateConfigurationMsg(v)}
        case 83:
          var v: Account_RegisterDomainMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountRegisterDomainMsg(v)}
        case 84:
          var v: Account_ReplaceAccountMsgFeesMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountMsgFeesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountReplaceAccountMsgFeesMsg(v)}
        case 85:
          var v: Account_TransferDomainMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountTransferDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountTransferDomainMsg(v)}
        case 86:
          var v: Account_RenewDomainMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountRenewDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountRenewDomainMsg(v)}
        case 87:
          var v: Account_DeleteDomainMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountDeleteDomainMsg(v)}
        case 88:
          var v: Account_RegisterAccountMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountRegisterAccountMsg(v)}
        case 89:
          var v: Account_TransferAccountMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountTransferAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountTransferAccountMsg(v)}
        case 90:
          var v: Account_ReplaceAccountTargetsMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountReplaceAccountTargetsMsg(v)}
        case 91:
          var v: Account_DeleteAccountMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountDeleteAccountMsg(v)}
        case 92:
          var v: Account_FlushDomainMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountFlushDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountFlushDomainMsg(v)}
        case 93:
          var v: Account_RenewAccountMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountRenewAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountRenewAccountMsg(v)}
        case 94:
          var v: Account_AddAccountCertificateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountAddAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountAddAccountCertificateMsg(v)}
        case 95:
          var v: Account_DeleteAccountCertificateMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .accountDeleteAccountCertificateMsg(v)}
        case 97:
          var v: Cash_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .cashUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .cashUpdateConfigurationMsg(v)}
        case 98:
          var v: Txfee_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .txfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .txfeeUpdateConfigurationMsg(v)}
        case 99:
          var v: Termdeposit_CreateDepositContractMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .termdepositCreateDepositContractMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .termdepositCreateDepositContractMsg(v)}
        case 100:
          var v: Termdeposit_DepositMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .termdepositDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .termdepositDepositMsg(v)}
        case 101:
          var v: Termdeposit_ReleaseDepositMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .termdepositReleaseDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .termdepositReleaseDepositMsg(v)}
        case 102:
          var v: Termdeposit_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .termdepositUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .termdepositUpdateConfigurationMsg(v)}
        case 103:
          var v: Qualityscore_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .qualityscoreUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .qualityscoreUpdateConfigurationMsg(v)}
        case 104:
          var v: Preregistration_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .preregistrationUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .preregistrationUpdateConfigurationMsg(v)}
        case 105:
          var v: Msgfee_UpdateConfigurationMsg?
          if let current = _storage._option {
            try decoder.handleConflictingOneOf()
            if case .msgfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._option = .msgfeeUpdateConfigurationMsg(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._option {
      case .cashSendMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case .escrowReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .updateEscrowPartiesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      case .multisigUpdateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      case .validatorsApplyDiffMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      case .currencyCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      case .executeProposalBatchMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      case .usernameRegisterTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      case .usernameTransferTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      case .usernameChangeTokenTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      case .usernameUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      case .distributionCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      case .distributionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .distributionResetMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      case .migrationUpgradeSchemaMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      case .govUpdateElectorateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      case .govUpdateElectionRuleMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      case .govCreateTextResolutionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      case .msgfeeSetMsgFeeMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      case .datamigrationExecuteMigrationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      case .accountUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      case .accountRegisterDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      case .accountReplaceAccountMsgFeesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      case .accountTransferDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      case .accountRenewDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      case .accountDeleteDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      case .accountRegisterAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      case .accountTransferAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      case .accountReplaceAccountTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      case .accountDeleteAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      case .accountFlushDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
      case .accountRenewAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      case .accountAddAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
      case .accountDeleteAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
      case .cashUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
      case .txfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      case .termdepositCreateDepositContractMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      case .termdepositDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .termdepositReleaseDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .termdepositUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case .qualityscoreUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case .preregistrationUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      case .msgfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_ProposalOptions, rhs: Bnsd_ProposalOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._option != rhs_storage._option {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_ExecuteProposalBatchMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecuteProposalBatchMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.messages)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_ExecuteProposalBatchMsg, rhs: Bnsd_ExecuteProposalBatchMsg) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_ExecuteProposalBatchMsg.Union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Bnsd_ExecuteProposalBatchMsg.protoMessageName + ".Union"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    51: .standard(proto: "send_msg"),
    53: .standard(proto: "escrow_release_msg"),
    55: .standard(proto: "update_escrow_parties_msg"),
    57: .standard(proto: "multisig_update_msg"),
    58: .standard(proto: "validators_apply_diff_msg"),
    61: .standard(proto: "username_register_token_msg"),
    62: .standard(proto: "username_transfer_token_msg"),
    63: .standard(proto: "username_change_token_targets_msg"),
    64: .standard(proto: "username_update_configuration_msg"),
    66: .standard(proto: "distribution_create_msg"),
    67: .standard(proto: "distribution_msg"),
    68: .standard(proto: "distribution_reset_msg"),
    77: .standard(proto: "gov_update_electorate_msg"),
    78: .standard(proto: "gov_update_election_rule_msg"),
    79: .standard(proto: "gov_create_text_resolution_msg"),
    80: .standard(proto: "msgfee_set_msg_fee_msg"),
    81: .standard(proto: "datamigration_execute_migration_msg"),
    82: .standard(proto: "account_update_configuration_msg"),
    83: .standard(proto: "account_register_domain_msg"),
    84: .standard(proto: "account_replace_account_msg_fees_msg"),
    85: .standard(proto: "account_transfer_domain_msg"),
    86: .standard(proto: "account_renew_domain_msg"),
    87: .standard(proto: "account_delete_domain_msg"),
    88: .standard(proto: "account_register_account_msg"),
    89: .standard(proto: "account_transfer_account_msg"),
    90: .standard(proto: "account_replace_account_targets_msg"),
    91: .standard(proto: "account_delete_account_msg"),
    92: .standard(proto: "account_flush_domain_msg"),
    93: .standard(proto: "account_renew_account_msg"),
    94: .standard(proto: "account_add_account_certificate_msg"),
    95: .standard(proto: "account_delete_account_certificate_msg"),
    97: .standard(proto: "cash_update_configuration_msg"),
    98: .standard(proto: "txfee_update_configuration_msg"),
    99: .standard(proto: "termdeposit_create_deposit_contract_msg"),
    100: .standard(proto: "termdeposit_deposit_msg"),
    101: .standard(proto: "termdeposit_release_deposit_msg"),
    102: .standard(proto: "termdeposit_update_configuration_msg"),
    103: .standard(proto: "qualityscore_update_configuration_msg"),
    104: .standard(proto: "preregistration_update_configuration_msg"),
    105: .standard(proto: "msgfee_update_configuration_msg"),
  ]

  fileprivate class _StorageClass {
    var _sum: Bnsd_ExecuteProposalBatchMsg.Union.OneOf_Sum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sum = source._sum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 51:
          var v: Cash_SendMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .sendMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .sendMsg(v)}
        case 53:
          var v: Escrow_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReleaseMsg(v)}
        case 55:
          var v: Escrow_UpdatePartiesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .updateEscrowPartiesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .updateEscrowPartiesMsg(v)}
        case 57:
          var v: Multisig_UpdateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .multisigUpdateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .multisigUpdateMsg(v)}
        case 58:
          var v: Validators_ApplyDiffMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .validatorsApplyDiffMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .validatorsApplyDiffMsg(v)}
        case 61:
          var v: Username_RegisterTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameRegisterTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameRegisterTokenMsg(v)}
        case 62:
          var v: Username_TransferTokenMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameTransferTokenMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameTransferTokenMsg(v)}
        case 63:
          var v: Username_ChangeTokenTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameChangeTokenTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameChangeTokenTargetsMsg(v)}
        case 64:
          var v: Username_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .usernameUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .usernameUpdateConfigurationMsg(v)}
        case 66:
          var v: Distribution_CreateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionCreateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionCreateMsg(v)}
        case 67:
          var v: Distribution_DistributeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionMsg(v)}
        case 68:
          var v: Distribution_ResetMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionResetMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionResetMsg(v)}
        case 77:
          var v: Gov_UpdateElectorateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectorateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govUpdateElectorateMsg(v)}
        case 78:
          var v: Gov_UpdateElectionRuleMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govUpdateElectionRuleMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govUpdateElectionRuleMsg(v)}
        case 79:
          var v: Gov_CreateTextResolutionMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govCreateTextResolutionMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govCreateTextResolutionMsg(v)}
        case 80:
          var v: Msgfee_SetMsgFeeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeSetMsgFeeMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeSetMsgFeeMsg(v)}
        case 81:
          var v: Datamigration_ExecuteMigrationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .datamigrationExecuteMigrationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .datamigrationExecuteMigrationMsg(v)}
        case 82:
          var v: Account_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountUpdateConfigurationMsg(v)}
        case 83:
          var v: Account_RegisterDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterDomainMsg(v)}
        case 84:
          var v: Account_ReplaceAccountMsgFeesMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountMsgFeesMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountMsgFeesMsg(v)}
        case 85:
          var v: Account_TransferDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferDomainMsg(v)}
        case 86:
          var v: Account_RenewDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewDomainMsg(v)}
        case 87:
          var v: Account_DeleteDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteDomainMsg(v)}
        case 88:
          var v: Account_RegisterAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRegisterAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRegisterAccountMsg(v)}
        case 89:
          var v: Account_TransferAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountTransferAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountTransferAccountMsg(v)}
        case 90:
          var v: Account_ReplaceAccountTargetsMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountReplaceAccountTargetsMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountReplaceAccountTargetsMsg(v)}
        case 91:
          var v: Account_DeleteAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountMsg(v)}
        case 92:
          var v: Account_FlushDomainMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountFlushDomainMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountFlushDomainMsg(v)}
        case 93:
          var v: Account_RenewAccountMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountRenewAccountMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountRenewAccountMsg(v)}
        case 94:
          var v: Account_AddAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountAddAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountAddAccountCertificateMsg(v)}
        case 95:
          var v: Account_DeleteAccountCertificateMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .accountDeleteAccountCertificateMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .accountDeleteAccountCertificateMsg(v)}
        case 97:
          var v: Cash_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .cashUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .cashUpdateConfigurationMsg(v)}
        case 98:
          var v: Txfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .txfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .txfeeUpdateConfigurationMsg(v)}
        case 99:
          var v: Termdeposit_CreateDepositContractMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositCreateDepositContractMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositCreateDepositContractMsg(v)}
        case 100:
          var v: Termdeposit_DepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositDepositMsg(v)}
        case 101:
          var v: Termdeposit_ReleaseDepositMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositReleaseDepositMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositReleaseDepositMsg(v)}
        case 102:
          var v: Termdeposit_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .termdepositUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .termdepositUpdateConfigurationMsg(v)}
        case 103:
          var v: Qualityscore_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .qualityscoreUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .qualityscoreUpdateConfigurationMsg(v)}
        case 104:
          var v: Preregistration_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .preregistrationUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .preregistrationUpdateConfigurationMsg(v)}
        case 105:
          var v: Msgfee_UpdateConfigurationMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .msgfeeUpdateConfigurationMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .msgfeeUpdateConfigurationMsg(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._sum {
      case .sendMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      case .escrowReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .updateEscrowPartiesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      case .multisigUpdateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      case .validatorsApplyDiffMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      case .usernameRegisterTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      case .usernameTransferTokenMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      case .usernameChangeTokenTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      case .usernameUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      case .distributionCreateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      case .distributionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .distributionResetMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      case .govUpdateElectorateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      case .govUpdateElectionRuleMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      case .govCreateTextResolutionMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      case .msgfeeSetMsgFeeMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      case .datamigrationExecuteMigrationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      case .accountUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      case .accountRegisterDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      case .accountReplaceAccountMsgFeesMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      case .accountTransferDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      case .accountRenewDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      case .accountDeleteDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      case .accountRegisterAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      case .accountTransferAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
      case .accountReplaceAccountTargetsMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
      case .accountDeleteAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
      case .accountFlushDomainMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
      case .accountRenewAccountMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
      case .accountAddAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
      case .accountDeleteAccountCertificateMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
      case .cashUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
      case .txfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
      case .termdepositCreateDepositContractMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
      case .termdepositDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      case .termdepositReleaseDepositMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .termdepositUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      case .qualityscoreUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case .preregistrationUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      case .msgfeeUpdateConfigurationMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_ExecuteProposalBatchMsg.Union, rhs: Bnsd_ExecuteProposalBatchMsg.Union) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sum != rhs_storage._sum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bnsd_CronTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CronTask"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticators"),
    53: .standard(proto: "escrow_release_msg"),
    54: .standard(proto: "escrow_return_msg"),
    67: .standard(proto: "distribution_distribute_msg"),
    71: .standard(proto: "aswap_release_msg"),
    76: .standard(proto: "gov_tally_msg"),
  ]

  fileprivate class _StorageClass {
    var _authenticators: [Data] = []
    var _sum: Bnsd_CronTask.OneOf_Sum?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _authenticators = source._authenticators
      _sum = source._sum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedBytesField(value: &_storage._authenticators)
        case 53:
          var v: Escrow_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReleaseMsg(v)}
        case 54:
          var v: Escrow_ReturnMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .escrowReturnMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .escrowReturnMsg(v)}
        case 67:
          var v: Distribution_DistributeMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .distributionDistributeMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .distributionDistributeMsg(v)}
        case 71:
          var v: Aswap_ReleaseMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .aswapReleaseMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .aswapReleaseMsg(v)}
        case 76:
          var v: Gov_TallyMsg?
          if let current = _storage._sum {
            try decoder.handleConflictingOneOf()
            if case .govTallyMsg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sum = .govTallyMsg(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._authenticators.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._authenticators, fieldNumber: 1)
      }
      switch _storage._sum {
      case .escrowReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      case .escrowReturnMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      case .distributionDistributeMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      case .aswapReleaseMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      case .govTallyMsg(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Bnsd_CronTask, rhs: Bnsd_CronTask) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authenticators != rhs_storage._authenticators {return false}
        if _storage._sum != rhs_storage._sum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
