// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cmd/bnsd/x/termdeposit/codec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// DepositContract is an entity created in order to allow investment deposits.
/// Anyone can deposit funds and therefore sign a deposit contract in order to
/// lock funds and receive appropriate interest after the contract expires.
struct Termdeposit_DepositContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Valid since defines the beginning of when the contract is active.
  var validSince: Int64 {
    get {return _storage._validSince}
    set {_uniqueStorage()._validSince = newValue}
  }

  /// An expiration date for this deposit contract. After this deadline, all
  /// depositor funds are released and deposit contract is no longer active.
  var validUntil: Int64 {
    get {return _storage._validUntil}
    set {_uniqueStorage()._validUntil = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Deposit represents a single fund deposition. Deposited funds are locked
/// until the contract expiration.
struct Termdeposit_Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Deposit contract ID that this funds allocation was made with.
  var depositContractID: Data {
    get {return _storage._depositContractID}
    set {_uniqueStorage()._depositContractID = newValue}
  }

  /// Total amount that was deposited within a contract. Must be IOV tokens.
  /// This information is used when computing each depositor reward. It is used
  /// instead of looking at the actual wallet state, so that it is not possible
  /// to increase the value of a deposit wallet only shortly before the
  /// computation.
  var amount: Coin_Coin {
    get {return _storage._amount ?? Coin_Coin()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// Pro-rated interest rate as detailed in the Confluence spec.
  var rate: Weave_Fraction {
    get {return _storage._rate ?? Weave_Fraction()}
    set {_uniqueStorage()._rate = newValue}
  }
  /// Returns true if `rate` has been explicitly set.
  var hasRate: Bool {return _storage._rate != nil}
  /// Clears the value of `rate`. Subsequent reads from it will return its default value.
  mutating func clearRate() {_uniqueStorage()._rate = nil}

  /// Payback is an address that locked funds and interest are send back to once
  /// the contract expires.
  var depositor: Data {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  /// Released flag is used to determin whether the funds locked by this deposit
  /// were already released or not.
  var released: Bool {
    get {return _storage._released}
    set {_uniqueStorage()._released = newValue}
  }

  /// CreatedAt is set to the wall clock value at the deposit creation time.
  var createdAt: Int64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Configuration is a dynamic configuration used by this extension, managed by
/// the functionality provided by gconf package.
struct Termdeposit_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Owner is present to implement gconf.OwnedConfig interface. Owner is
  /// allowed to update the configuration.
  var owner: Data {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  /// Admin is an address that is able to create deposit contracts.
  var admin: Data {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  /// A list of bonus values applied to each created Deposit instance.
  var bonuses: [Termdeposit_DepositBonus] {
    get {return _storage._bonuses}
    set {_uniqueStorage()._bonuses = newValue}
  }

  /// Base rates defines a list of addresses that have their q-score value fixed.
  var baseRates: [Termdeposit_CustomRate] {
    get {return _storage._baseRates}
    set {_uniqueStorage()._baseRates = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Custom Rate allows to declare a fixed rate value for an address.
struct Termdeposit_CustomRate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  var rate: Weave_Fraction {
    get {return _storage._rate ?? Weave_Fraction()}
    set {_uniqueStorage()._rate = newValue}
  }
  /// Returns true if `rate` has been explicitly set.
  var hasRate: Bool {return _storage._rate != nil}
  /// Clears the value of `rate`. Subsequent reads from it will return its default value.
  mutating func clearRate() {_uniqueStorage()._rate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DepositBonus defines a bonus value used to calculate deposit rate. The
/// longer the deposit period, the higher the deposit bonus should be.
struct Termdeposit_DepositBonus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deposit minimal lockin period required to use this bonus.
  var lockinPeriod: Int32 {
    get {return _storage._lockinPeriod}
    set {_uniqueStorage()._lockinPeriod = newValue}
  }

  /// Bonus rate for given range.
  var bonus: Weave_Fraction {
    get {return _storage._bonus ?? Weave_Fraction()}
    set {_uniqueStorage()._bonus = newValue}
  }
  /// Returns true if `bonus` has been explicitly set.
  var hasBonus: Bool {return _storage._bonus != nil}
  /// Clears the value of `bonus`. Subsequent reads from it will return its default value.
  mutating func clearBonus() {_uniqueStorage()._bonus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CreateDepositContractMsg creates a new DepositContract entity. This message
/// must be signed by the admin as configured via the Configuration entity.
struct Termdeposit_CreateDepositContractMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// An activation date for the newly created deposit contract.
  var validSince: Int64 {
    get {return _storage._validSince}
    set {_uniqueStorage()._validSince = newValue}
  }

  /// An expiration date for the newly created deposit contract.
  var validUntil: Int64 {
    get {return _storage._validUntil}
    set {_uniqueStorage()._validUntil = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DepositMsg can be send by anyone to deposit funds within a non expired
/// contract. Funds will stay locked until that contract expiration date.
struct Termdeposit_DepositMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Deposit contract ID that this funds allocation was made with. Contract
  /// must not be expired.
  var depositContractID: Data {
    get {return _storage._depositContractID}
    set {_uniqueStorage()._depositContractID = newValue}
  }

  /// Total amount that was deposited within a contract. Must be IOV tokens.
  var amount: Coin_Coin {
    get {return _storage._amount ?? Coin_Coin()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// Payback is an address that locked funds and interest are send back to once
  /// the contract expires.
  var depositor: Data {
    get {return _storage._depositor}
    set {_uniqueStorage()._depositor = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReleaseDepositMsg cause releasing of all funds allocated within given
/// deposit. Related contract must be expired. Anyone can submit this message.
struct Termdeposit_ReleaseDepositMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// ID of the deposit that is to be released.
  var depositID: Data {
    get {return _storage._depositID}
    set {_uniqueStorage()._depositID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Termdeposit_UpdateConfigurationMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var patch: Termdeposit_Configuration {
    get {return _storage._patch ?? Termdeposit_Configuration()}
    set {_uniqueStorage()._patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  var hasPatch: Bool {return _storage._patch != nil}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  mutating func clearPatch() {_uniqueStorage()._patch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "termdeposit"

extension Termdeposit_DepositContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "valid_since"),
    3: .standard(proto: "valid_until"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _validSince: Int64 = 0
    var _validUntil: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _validSince = source._validSince
      _validUntil = source._validUntil
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._validSince)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._validUntil)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._validSince != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validSince, fieldNumber: 2)
      }
      if _storage._validUntil != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validUntil, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_DepositContract, rhs: Termdeposit_DepositContract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._validSince != rhs_storage._validSince {return false}
        if _storage._validUntil != rhs_storage._validUntil {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "deposit_contract_id"),
    3: .same(proto: "amount"),
    4: .same(proto: "rate"),
    5: .same(proto: "depositor"),
    6: .same(proto: "released"),
    7: .standard(proto: "created_at"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _depositContractID: Data = SwiftProtobuf.Internal.emptyData
    var _amount: Coin_Coin? = nil
    var _rate: Weave_Fraction? = nil
    var _depositor: Data = SwiftProtobuf.Internal.emptyData
    var _released: Bool = false
    var _createdAt: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _depositContractID = source._depositContractID
      _amount = source._amount
      _rate = source._rate
      _depositor = source._depositor
      _released = source._released
      _createdAt = source._createdAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._depositContractID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._rate)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._depositor)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._released)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._createdAt)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._depositContractID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._depositContractID, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._rate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._depositor, fieldNumber: 5)
      }
      if _storage._released != false {
        try visitor.visitSingularBoolField(value: _storage._released, fieldNumber: 6)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createdAt, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_Deposit, rhs: Termdeposit_Deposit) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._depositContractID != rhs_storage._depositContractID {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._rate != rhs_storage._rate {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        if _storage._released != rhs_storage._released {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "owner"),
    3: .same(proto: "admin"),
    4: .same(proto: "bonuses"),
    5: .standard(proto: "base_rates"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _owner: Data = SwiftProtobuf.Internal.emptyData
    var _admin: Data = SwiftProtobuf.Internal.emptyData
    var _bonuses: [Termdeposit_DepositBonus] = []
    var _baseRates: [Termdeposit_CustomRate] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _owner = source._owner
      _admin = source._admin
      _bonuses = source._bonuses
      _baseRates = source._baseRates
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._owner)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._admin)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._bonuses)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._baseRates)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._admin, fieldNumber: 3)
      }
      if !_storage._bonuses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bonuses, fieldNumber: 4)
      }
      if !_storage._baseRates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._baseRates, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_Configuration, rhs: Termdeposit_Configuration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._bonuses != rhs_storage._bonuses {return false}
        if _storage._baseRates != rhs_storage._baseRates {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_CustomRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomRate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "rate"),
  ]

  fileprivate class _StorageClass {
    var _address: Data = SwiftProtobuf.Internal.emptyData
    var _rate: Weave_Fraction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _address = source._address
      _rate = source._rate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._address)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._address.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 1)
      }
      if let v = _storage._rate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_CustomRate, rhs: Termdeposit_CustomRate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._address != rhs_storage._address {return false}
        if _storage._rate != rhs_storage._rate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_DepositBonus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositBonus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lockin_period"),
    2: .same(proto: "bonus"),
  ]

  fileprivate class _StorageClass {
    var _lockinPeriod: Int32 = 0
    var _bonus: Weave_Fraction? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lockinPeriod = source._lockinPeriod
      _bonus = source._bonus
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._lockinPeriod)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._bonus)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._lockinPeriod != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lockinPeriod, fieldNumber: 1)
      }
      if let v = _storage._bonus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_DepositBonus, rhs: Termdeposit_DepositBonus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lockinPeriod != rhs_storage._lockinPeriod {return false}
        if _storage._bonus != rhs_storage._bonus {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_CreateDepositContractMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDepositContractMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "valid_since"),
    3: .standard(proto: "valid_until"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _validSince: Int64 = 0
    var _validUntil: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _validSince = source._validSince
      _validUntil = source._validUntil
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._validSince)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._validUntil)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._validSince != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validSince, fieldNumber: 2)
      }
      if _storage._validUntil != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validUntil, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_CreateDepositContractMsg, rhs: Termdeposit_CreateDepositContractMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._validSince != rhs_storage._validSince {return false}
        if _storage._validUntil != rhs_storage._validUntil {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_DepositMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "deposit_contract_id"),
    3: .same(proto: "amount"),
    4: .same(proto: "depositor"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _depositContractID: Data = SwiftProtobuf.Internal.emptyData
    var _amount: Coin_Coin? = nil
    var _depositor: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _depositContractID = source._depositContractID
      _amount = source._amount
      _depositor = source._depositor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._depositContractID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._amount)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._depositor)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._depositContractID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._depositContractID, fieldNumber: 2)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._depositor.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._depositor, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_DepositMsg, rhs: Termdeposit_DepositMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._depositContractID != rhs_storage._depositContractID {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._depositor != rhs_storage._depositor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_ReleaseDepositMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseDepositMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .standard(proto: "deposit_id"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _depositID: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _depositID = source._depositID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._depositID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._depositID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._depositID, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_ReleaseDepositMsg, rhs: Termdeposit_ReleaseDepositMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._depositID != rhs_storage._depositID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Termdeposit_UpdateConfigurationMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateConfigurationMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "patch"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _patch: Termdeposit_Configuration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _patch = source._patch
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._patch)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._patch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Termdeposit_UpdateConfigurationMsg, rhs: Termdeposit_UpdateConfigurationMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._patch != rhs_storage._patch {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
