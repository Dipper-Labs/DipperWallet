// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cmd/bnsd/x/account/codec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Domain represents an account domain.
///
/// Domain is a container for accounts. Account representation is
/// `<name>*<domain>`.
///
/// Each domain admin controls all accounts that belong to that domain.
/// Each domain controls expiration of all accounts that belong to that domain.
struct Account_Domain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// Admin is a weave.Address that controls this domain and all accounts that
  /// belong to this domain.
  var admin: Data {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  /// Valid until defines the expiration date for the domain. Expired domain
  /// cannot be used or modified. None of the accounts that belong to an expired
  /// domain can be used of modified as well.
  var validUntil: Int64 {
    get {return _storage._validUntil}
    set {_uniqueStorage()._validUntil = newValue}
  }

  /// Has Superuser is a feature switch flag.
  var hasSuperuser_p: Bool {
    get {return _storage._hasSuperuser_p}
    set {_uniqueStorage()._hasSuperuser_p = newValue}
  }

  /// Msg fees declares an optional list of additional fees that paying is
  /// required when processing a message within this domain.
  var msgFees: [Account_AccountMsgFee] {
    get {return _storage._msgFees}
    set {_uniqueStorage()._msgFees = newValue}
  }

  /// Account review defines the duration of the account renewal period for each
  /// account that belongs to this domain.
  var accountRenew: Int64 {
    get {return _storage._accountRenew}
    set {_uniqueStorage()._accountRenew = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// AccountMsgFee defines a fee for processing a message of a given type,
/// determined by that message path. This is a way to declare an additional
/// price for processing a message in a scope of a domain.
struct Account_AccountMsgFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msgPath: String {
    get {return _storage._msgPath}
    set {_uniqueStorage()._msgPath = newValue}
  }

  var fee: Coin_Coin {
    get {return _storage._fee ?? Coin_Coin()}
    set {_uniqueStorage()._fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return _storage._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {_uniqueStorage()._fee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Account represents an account that belongs to a domain.
///
/// String representation of an account is `<name>*<domain>`. Empty name is an
/// acceptable account string. Complete validation rules for name and domain are
/// declared by configuration entity.
///
/// An account must always belong to an existing domain.
struct Account_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Domain references a domain that this account belongs to.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Owner is a weave.Address that controls this account. Can be empty.
  ///
  /// An account can be administrated by the domain admin. In addition,
  /// ownership can be assigned to an address to allow another party to manage
  /// selected account.
  var owner: Data {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  /// Valid until defines the expiration date for the account. Expired account
  /// cannot be used or modified. This date is always considered in context of
  /// the domain that this account belongs. Expired domain expires all belonging
  /// accounts as well, event if that account valid until date is not yet due.
  var validUntil: Int64 {
    get {return _storage._validUntil}
    set {_uniqueStorage()._validUntil = newValue}
  }

  var targets: [Account_BlockchainAddress] {
    get {return _storage._targets}
    set {_uniqueStorage()._targets = newValue}
  }

  var certificates: [Data] {
    get {return _storage._certificates}
    set {_uniqueStorage()._certificates = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// BlockchainAddress represents a blochain address. This structure clubs together
/// blokchain ID together with an address on that network. It is used to point
/// to an address on any blockchain network.
struct Account_BlockchainAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An arbitrary blockchain ID.
  var blockchainID: String = String()

  /// An address on the specified blockchain network. Address is not a
  /// weave.Address as we cannot know what is the format of an address on the
  /// chain that this token instance links to. Because we do not know the rules
  /// to validate an address for any blockchain ID, this is an arbitrary bulk of
  /// data.
  /// It is more convenient to always use encoded representation of each address
  /// and store it as a string. Using bytes while compact is not as comfortable
  /// to use.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration is a dynamic configuration used by this extension, managed by
/// the functionality provided by gconf package.
struct Account_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Owner is present to implement gconf.OwnedConfig interface
  /// This defines the Address that is allowed to update the Configuration object and is
  /// needed to make use of gconf.NewUpdateConfigurationHandler
  var owner: Data {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  /// Valid domain defines a regular expression that every valid domain of an
  /// account must match. Rule must not include the asterisk (*) character.
  var validDomain: String {
    get {return _storage._validDomain}
    set {_uniqueStorage()._validDomain = newValue}
  }

  /// Valid name defines a regular expression that every valid name of an
  /// account must match. Rule must not include the asterisk (*) character.
  var validName: String {
    get {return _storage._validName}
    set {_uniqueStorage()._validName = newValue}
  }

  /// Valid blockchain ID defines a regular expression that a valid target
  /// blockchain ID must match.
  var validBlockchainID: String {
    get {return _storage._validBlockchainID}
    set {_uniqueStorage()._validBlockchainID = newValue}
  }

  /// Valid blockchain address defines a regular expression that a valid target
  /// blockchain address must match.
  var validBlockchainAddress: String {
    get {return _storage._validBlockchainAddress}
    set {_uniqueStorage()._validBlockchainAddress = newValue}
  }

  /// Domain review defines the duration of the domain renewal period.
  var domainRenew: Int64 {
    get {return _storage._domainRenew}
    set {_uniqueStorage()._domainRenew = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// UpdateConfigurationMsg is used by the gconf extension to update the
/// configuration.
struct Account_UpdateConfigurationMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var patch: Account_Configuration {
    get {return _storage._patch ?? Account_Configuration()}
    set {_uniqueStorage()._patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  var hasPatch: Bool {return _storage._patch != nil}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  mutating func clearPatch() {_uniqueStorage()._patch = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RegisterDomainMsg is issuing registration of a new domain. Requested
/// domain name must be available (not yet registed) in order for the request to
/// succeed.
/// Registering a domain creates an account with no name that belongs to this
/// domain.
struct Account_RegisterDomainMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// Admin holds the address of the newly registered domain.
  var admin: Data {
    get {return _storage._admin}
    set {_uniqueStorage()._admin = newValue}
  }

  /// Has Superuser is a feature switch flag.
  var hasSuperuser_p: Bool {
    get {return _storage._hasSuperuser_p}
    set {_uniqueStorage()._hasSuperuser_p = newValue}
  }

  /// Third party token is an arbitrary data that can be provided by a middleman
  /// (i.e. retailer) that although does not participate directly in the
  /// transaction, helped a user to register a domain. Storing a third party
  /// token helps identify contribution of such party later.
  var thirdPartyToken: Data {
    get {return _storage._thirdPartyToken}
    set {_uniqueStorage()._thirdPartyToken = newValue}
  }

  var msgFees: [Account_AccountMsgFee] {
    get {return _storage._msgFees}
    set {_uniqueStorage()._msgFees = newValue}
  }

  var accountRenew: Int64 {
    get {return _storage._accountRenew}
    set {_uniqueStorage()._accountRenew = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplaceMsgFeesMsg is configuring a set of additional prices that must be
/// paid in order to process messages for accounts that belong to this domain.
struct Account_ReplaceAccountMsgFeesMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Name of the domain that is configured.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// A set of message fees that will replacce existing configuration.
  var newMsgFees: [Account_AccountMsgFee] {
    get {return _storage._newMsgFees}
    set {_uniqueStorage()._newMsgFees = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TransferDomainMsg is issuing a change of the admin for the specified domain.
struct Account_TransferDomainMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Name of the domain that is transferred.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// New admin holds the address that the ownership of the domain is
  /// transferred to.
  var newAdmin: Data {
    get {return _storage._newAdmin}
    set {_uniqueStorage()._newAdmin = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RenewDomainMsg is issuing a domain expiration time extension. Extension
/// period is defined by the configuration entity.
struct Account_RenewDomainMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Name of the domain that is transferred.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeleteDomainMsg issues deletion of a domain and all accounts that belong to
/// that domain.
struct Account_DeleteDomainMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Name of the domain that is deleted.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RegisterAccountMsg issues registration of an account. Requested domain must
/// exist and belong to the same user that signs this message.
/// If domain does not have a public registration enabled, transaction must be
/// signed by the domain admin.
struct Account_RegisterAccountMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Domain that a new account is the be registered under.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// Name that a new account is the be registered with.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Owner holds the address of the newly registered account. Can be empty to
  /// leave the administration to the domain owner only.
  var owner: Data {
    get {return _storage._owner}
    set {_uniqueStorage()._owner = newValue}
  }

  var targets: [Account_BlockchainAddress] {
    get {return _storage._targets}
    set {_uniqueStorage()._targets = newValue}
  }

  /// Third party token is an arbitrary data that can be provided by a middleman
  /// (i.e. retailer) that although does not participate directly in the
  /// transaction, helped a user to renew a domain. Storing a third party token
  /// helps identify contribution of such party later.
  var thirdPartyToken: Data {
    get {return _storage._thirdPartyToken}
    set {_uniqueStorage()._thirdPartyToken = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TransferAccountMsg is issuing an ownership transfer over specified account.
/// Transfering an account ownership does not affect related domain owner
/// permissions to administrate that account.
/// Domain that this account belongs to determines if the account owner can
/// transfer ownership. Domain admin can always transfer ownership.
struct Account_TransferAccountMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// New owner holds the address that the ownership of the domain is
  /// transferred to.
  var newOwner: Data {
    get {return _storage._newOwner}
    set {_uniqueStorage()._newOwner = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ReplaceAccountTargetsMsg is issuing rewrite of all targets that given
/// account points to.
struct Account_ReplaceAccountTargetsMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var newTargets: [Account_BlockchainAddress] {
    get {return _storage._newTargets}
    set {_uniqueStorage()._newTargets = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// DeleteAccountMsg issues deletion of a name that belongs to given domain.
/// Message must be signed by the domain owner.
struct Account_DeleteAccountMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// FlushDomainMsg issues deletion of all names (except the one with an empty
/// name) that belongs to given domain.
/// Message must be signed by the domain admin.
struct Account_FlushDomainMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// RenewAccountMsg is issuing an account expiration time extension. Extension
/// period is defined by the domain that this account belongs to.
struct Account_RenewAccountMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Name of the domain that is transferred.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Account_AddAccountCertificateMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Domain that account belongs to.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// Account name.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Certificate content.
  var certificate: Data {
    get {return _storage._certificate}
    set {_uniqueStorage()._certificate = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Account_DeleteAccountCertificateMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadata: Weave_Metadata {
    get {return _storage._metadata ?? Weave_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Domain that account belongs to.
  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  /// Account name.
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Certificate hash is a sha256 checksum of the certificate content.
  /// Certificates are bytes without any identifier. They are also not parsed by
  /// the application. We optimize transferred data by sending only a checksum
  /// of a certificate in order to identify it.
  var certificateHash: Data {
    get {return _storage._certificateHash}
    set {_uniqueStorage()._certificateHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "account"

extension Account_Domain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Domain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "admin"),
    4: .standard(proto: "valid_until"),
    5: .standard(proto: "has_superuser"),
    6: .standard(proto: "msg_fees"),
    7: .standard(proto: "account_renew"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _admin: Data = SwiftProtobuf.Internal.emptyData
    var _validUntil: Int64 = 0
    var _hasSuperuser_p: Bool = false
    var _msgFees: [Account_AccountMsgFee] = []
    var _accountRenew: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _admin = source._admin
      _validUntil = source._validUntil
      _hasSuperuser_p = source._hasSuperuser_p
      _msgFees = source._msgFees
      _accountRenew = source._accountRenew
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._admin)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._validUntil)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._hasSuperuser_p)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._msgFees)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._accountRenew)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._admin, fieldNumber: 3)
      }
      if _storage._validUntil != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validUntil, fieldNumber: 4)
      }
      if _storage._hasSuperuser_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSuperuser_p, fieldNumber: 5)
      }
      if !_storage._msgFees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._msgFees, fieldNumber: 6)
      }
      if _storage._accountRenew != 0 {
        try visitor.visitSingularInt64Field(value: _storage._accountRenew, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_Domain, rhs: Account_Domain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._validUntil != rhs_storage._validUntil {return false}
        if _storage._hasSuperuser_p != rhs_storage._hasSuperuser_p {return false}
        if _storage._msgFees != rhs_storage._msgFees {return false}
        if _storage._accountRenew != rhs_storage._accountRenew {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_AccountMsgFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountMsgFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_path"),
    2: .same(proto: "fee"),
  ]

  fileprivate class _StorageClass {
    var _msgPath: String = String()
    var _fee: Coin_Coin? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _msgPath = source._msgPath
      _fee = source._fee
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._msgPath)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._fee)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._msgPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._msgPath, fieldNumber: 1)
      }
      if let v = _storage._fee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_AccountMsgFee, rhs: Account_AccountMsgFee) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._msgPath != rhs_storage._msgPath {return false}
        if _storage._fee != rhs_storage._fee {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .same(proto: "owner"),
    5: .standard(proto: "valid_until"),
    6: .same(proto: "targets"),
    7: .same(proto: "certificates"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _owner: Data = SwiftProtobuf.Internal.emptyData
    var _validUntil: Int64 = 0
    var _targets: [Account_BlockchainAddress] = []
    var _certificates: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _owner = source._owner
      _validUntil = source._validUntil
      _targets = source._targets
      _certificates = source._certificates
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._owner)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._validUntil)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._targets)
        case 7: try decoder.decodeRepeatedBytesField(value: &_storage._certificates)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._owner, fieldNumber: 4)
      }
      if _storage._validUntil != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validUntil, fieldNumber: 5)
      }
      if !_storage._targets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._targets, fieldNumber: 6)
      }
      if !_storage._certificates.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._certificates, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_Account, rhs: Account_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._validUntil != rhs_storage._validUntil {return false}
        if _storage._targets != rhs_storage._targets {return false}
        if _storage._certificates != rhs_storage._certificates {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_BlockchainAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockchainAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blockchain_id"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.blockchainID)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blockchainID.isEmpty {
      try visitor.visitSingularStringField(value: self.blockchainID, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_BlockchainAddress, rhs: Account_BlockchainAddress) -> Bool {
    if lhs.blockchainID != rhs.blockchainID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "owner"),
    3: .standard(proto: "valid_domain"),
    4: .standard(proto: "valid_name"),
    5: .standard(proto: "valid_blockchain_id"),
    6: .standard(proto: "valid_blockchain_address"),
    7: .standard(proto: "domain_renew"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _owner: Data = SwiftProtobuf.Internal.emptyData
    var _validDomain: String = String()
    var _validName: String = String()
    var _validBlockchainID: String = String()
    var _validBlockchainAddress: String = String()
    var _domainRenew: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _owner = source._owner
      _validDomain = source._validDomain
      _validName = source._validName
      _validBlockchainID = source._validBlockchainID
      _validBlockchainAddress = source._validBlockchainAddress
      _domainRenew = source._domainRenew
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._owner)
        case 3: try decoder.decodeSingularStringField(value: &_storage._validDomain)
        case 4: try decoder.decodeSingularStringField(value: &_storage._validName)
        case 5: try decoder.decodeSingularStringField(value: &_storage._validBlockchainID)
        case 6: try decoder.decodeSingularStringField(value: &_storage._validBlockchainAddress)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._domainRenew)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._owner, fieldNumber: 2)
      }
      if !_storage._validDomain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._validDomain, fieldNumber: 3)
      }
      if !_storage._validName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._validName, fieldNumber: 4)
      }
      if !_storage._validBlockchainID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._validBlockchainID, fieldNumber: 5)
      }
      if !_storage._validBlockchainAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._validBlockchainAddress, fieldNumber: 6)
      }
      if _storage._domainRenew != 0 {
        try visitor.visitSingularInt64Field(value: _storage._domainRenew, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_Configuration, rhs: Account_Configuration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._validDomain != rhs_storage._validDomain {return false}
        if _storage._validName != rhs_storage._validName {return false}
        if _storage._validBlockchainID != rhs_storage._validBlockchainID {return false}
        if _storage._validBlockchainAddress != rhs_storage._validBlockchainAddress {return false}
        if _storage._domainRenew != rhs_storage._domainRenew {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_UpdateConfigurationMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateConfigurationMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "patch"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _patch: Account_Configuration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _patch = source._patch
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._patch)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._patch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_UpdateConfigurationMsg, rhs: Account_UpdateConfigurationMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._patch != rhs_storage._patch {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_RegisterDomainMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDomainMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "admin"),
    4: .standard(proto: "has_superuser"),
    5: .standard(proto: "third_party_token"),
    6: .standard(proto: "msg_fees"),
    7: .standard(proto: "account_renew"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _admin: Data = SwiftProtobuf.Internal.emptyData
    var _hasSuperuser_p: Bool = false
    var _thirdPartyToken: Data = SwiftProtobuf.Internal.emptyData
    var _msgFees: [Account_AccountMsgFee] = []
    var _accountRenew: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _admin = source._admin
      _hasSuperuser_p = source._hasSuperuser_p
      _thirdPartyToken = source._thirdPartyToken
      _msgFees = source._msgFees
      _accountRenew = source._accountRenew
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._admin)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._hasSuperuser_p)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._thirdPartyToken)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._msgFees)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._accountRenew)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._admin.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._admin, fieldNumber: 3)
      }
      if _storage._hasSuperuser_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSuperuser_p, fieldNumber: 4)
      }
      if !_storage._thirdPartyToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._thirdPartyToken, fieldNumber: 5)
      }
      if !_storage._msgFees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._msgFees, fieldNumber: 6)
      }
      if _storage._accountRenew != 0 {
        try visitor.visitSingularInt64Field(value: _storage._accountRenew, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_RegisterDomainMsg, rhs: Account_RegisterDomainMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._hasSuperuser_p != rhs_storage._hasSuperuser_p {return false}
        if _storage._thirdPartyToken != rhs_storage._thirdPartyToken {return false}
        if _storage._msgFees != rhs_storage._msgFees {return false}
        if _storage._accountRenew != rhs_storage._accountRenew {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_ReplaceAccountMsgFeesMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceAccountMsgFeesMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    6: .standard(proto: "new_msg_fees"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _newMsgFees: [Account_AccountMsgFee] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _newMsgFees = source._newMsgFees
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._newMsgFees)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._newMsgFees.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newMsgFees, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_ReplaceAccountMsgFeesMsg, rhs: Account_ReplaceAccountMsgFeesMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._newMsgFees != rhs_storage._newMsgFees {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_TransferDomainMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferDomainMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .standard(proto: "new_admin"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _newAdmin: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _newAdmin = source._newAdmin
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._newAdmin)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._newAdmin.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._newAdmin, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_TransferDomainMsg, rhs: Account_TransferDomainMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._newAdmin != rhs_storage._newAdmin {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_RenewDomainMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RenewDomainMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_RenewDomainMsg, rhs: Account_RenewDomainMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_DeleteDomainMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteDomainMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_DeleteDomainMsg, rhs: Account_DeleteDomainMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_RegisterAccountMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterAccountMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .same(proto: "owner"),
    5: .same(proto: "targets"),
    6: .standard(proto: "third_party_token"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _owner: Data = SwiftProtobuf.Internal.emptyData
    var _targets: [Account_BlockchainAddress] = []
    var _thirdPartyToken: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _owner = source._owner
      _targets = source._targets
      _thirdPartyToken = source._thirdPartyToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._owner)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._targets)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._thirdPartyToken)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._owner.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._owner, fieldNumber: 4)
      }
      if !_storage._targets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._targets, fieldNumber: 5)
      }
      if !_storage._thirdPartyToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._thirdPartyToken, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_RegisterAccountMsg, rhs: Account_RegisterAccountMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._targets != rhs_storage._targets {return false}
        if _storage._thirdPartyToken != rhs_storage._thirdPartyToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_TransferAccountMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransferAccountMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .standard(proto: "new_owner"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _newOwner: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _newOwner = source._newOwner
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._newOwner)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._newOwner.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._newOwner, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_TransferAccountMsg, rhs: Account_TransferAccountMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._newOwner != rhs_storage._newOwner {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_ReplaceAccountTargetsMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceAccountTargetsMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    4: .same(proto: "name"),
    5: .standard(proto: "new_targets"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _newTargets: [Account_BlockchainAddress] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _newTargets = source._newTargets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 4: try decoder.decodeSingularStringField(value: &_storage._name)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._newTargets)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 4)
      }
      if !_storage._newTargets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._newTargets, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_ReplaceAccountTargetsMsg, rhs: Account_ReplaceAccountTargetsMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._newTargets != rhs_storage._newTargets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_DeleteAccountMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccountMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_DeleteAccountMsg, rhs: Account_DeleteAccountMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_FlushDomainMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlushDomainMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_FlushDomainMsg, rhs: Account_FlushDomainMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_RenewAccountMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RenewAccountMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_RenewAccountMsg, rhs: Account_RenewAccountMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_AddAccountCertificateMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddAccountCertificateMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .same(proto: "certificate"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _certificate: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _certificate = source._certificate
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._certificate)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._certificate.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._certificate, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_AddAccountCertificateMsg, rhs: Account_AddAccountCertificateMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._certificate != rhs_storage._certificate {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Account_DeleteAccountCertificateMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteAccountCertificateMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "domain"),
    3: .same(proto: "name"),
    4: .standard(proto: "certificate_hash"),
  ]

  fileprivate class _StorageClass {
    var _metadata: Weave_Metadata? = nil
    var _domain: String = String()
    var _name: String = String()
    var _certificateHash: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metadata = source._metadata
      _domain = source._domain
      _name = source._name
      _certificateHash = source._certificateHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 2: try decoder.decodeSingularStringField(value: &_storage._domain)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._certificateHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._certificateHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._certificateHash, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Account_DeleteAccountCertificateMsg, rhs: Account_DeleteAccountCertificateMsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._certificateHash != rhs_storage._certificateHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
